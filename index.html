<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gemspire - Match-3 Roguelike</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Orbitron', monospace;
    background: linear-gradient(135deg, #1e1e2e 0%, #2d1b3d 50%, #3e2723 100%);
    color: #e0e0e0;
    overflow: hidden;
    height: 100vh;
    position: relative;
}

.bg-animation {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0.1;
    z-index: -1;
}

.bg-particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: radial-gradient(circle, #7c3aed, transparent);
    border-radius: 50%;
    animation: float 6s ease-in-out infinite;
}

@keyframes float {
    0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.3; }
    50% { transform: translateY(-20px) rotate(180deg); opacity: 0.7; }
}

.game-container {
    display: flex;
    height: 100vh;
    padding: 20px;
    gap: 20px;
}

.game-board {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px;
    background: rgba(0, 0, 0, 0.3);
    padding: 20px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(124, 58, 237, 0.3);
    box-shadow: 0 0 30px rgba(124, 58, 237, 0.2);
    width: 420px;
    height: 420px;
    position: relative;
}

/* Container sits right under the board */
.active-relics-container {
  width: 420px;              /* match your board width */
  margin: 10px auto 0;       /* center below board */
  text-align: left;
  color: #ffd43b;
  border-radius: 12px;
  background: rgba(0,0,0,0.3);
  padding: 4px;
}

/* when >3 relics, extend the viewport down by 70px */
.active-relics-container.two-rows .active-relics-grid {
  max-height: 220px;      /* 150 + 70 */
}

.active-relics-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  /* always have at least one row that‚Äôs at least 50px tall */
  grid-template-rows: minmax(50px, auto);
  /* any additional rows fall back to auto */
  grid-auto-rows: auto;
  gap: 8px;
  max-height: 150px;
  overflow-y: auto;
  padding: 4px;
  background: rgba(0,0,0,0.3);
  border: 2px solid rgba(124,58,237,0.3);
  border-radius: 8px;
}

.active-relics-grid .relic {
  background: rgba(255,255,255,0.1);
  padding: 6px;
  border-radius: 6px;
  font-size: 12px;
  /* allow multi-line wrapping: */
  white-space: normal;
  word-break: break-word;
  /* remove any hidden overflow/ellipsis */
  overflow: visible;
  text-overflow: unset;
}

.gem {
    width: 50px;
    height: 50px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 24px;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative;
    overflow: hidden;
    border: 2px solid rgba(255, 255, 255, 0.2);
}

.gem.selected {
    transform: scale(1.15);
    box-shadow: 
        0 0 25px rgba(255, 255, 255, 0.8),
        0 0 40px rgba(124, 58, 237, 0.6),
        inset 0 0 15px rgba(255, 255, 255, 0.3);
    border: 3px solid rgba(255, 255, 255, 0.9);
    animation: selectedPulse 1.5s ease-in-out infinite;
    z-index: 10;
    position: relative;
}

.gem.matching {
    animation: pulse 0.5s ease-in-out;
}

.gem.special {
    box-shadow: 0 0 15px currentColor;
    border-color: gold;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); box-shadow: 0 0 30px currentColor; }
    100% { transform: scale(1); }
}

.gem.fire { background: linear-gradient(135deg, #ff6b6b, #ff8787); color: #fff; }
.gem.ice { background: linear-gradient(135deg, #74c0fc, #339af0); color: #fff; }
.gem.nature { background: linear-gradient(135deg, #51cf66, #37b24d); color: #fff; }
.gem.lightning { background: linear-gradient(135deg, #ffd43b, #fab005); color: #000; }
.gem.void { background: linear-gradient(135deg, #9775fa, #7c3aed); color: #fff; }

.consumable-btn:disabled,
.booster-btn:disabled,
.options-btn:disabled {
    background: rgba(107, 114, 128, 0.5) !important;
    cursor: not-allowed !important;
    transform: none !important;
    box-shadow: none !important;
}

.consumable-btn:disabled:hover,
.booster-btn:disabled:hover,
.options-btn:disabled:hover {
    background: rgba(107, 114, 128, 0.5) !important;
    transform: none !important;
    box-shadow: none !important;
}

.ui-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
    max-width: 300px;
    position: relative;
}

.stats-panel {
    background: rgba(0, 0, 0, 0.3);
    padding: 20px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(124, 58, 237, 0.3);
    position: relative;
}

.stat-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    font-size: 14px;
}

.stat-value {
    font-weight: bold;
    color: #7c3aed;
}

.moves-left {
    font-size: 24px;
    text-align: center;
    color: #ffd43b;
    font-weight: bold;
}

.floor-info {
    text-align: center;
    font-size: 18px;
    color: #e0e0e0;
    margin-bottom: 10px;
}

.progress-bar {
    width: 100%;
    height: 20px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #7c3aed, #9775fa);
    transition: width 0.5s ease;
    border-radius: 10px;
}

.relics-panel {
    background: rgba(0, 0, 0, 0.3);
    padding: 20px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(124, 58, 237, 0.3);
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 200px;
    max-height: 400px;
}

#relicsList {
    flex: 1;
    overflow-y: auto;
    padding-right: 8px;
    margin-right: -8px;
    min-height: 0;
}

/* Modern Scrollbar Styling */
#relicsList::-webkit-scrollbar {
    width: 8px;
}

#relicsList::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    margin: 4px 0;
}

#relicsList::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #7c3aed, #9775fa);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 6px rgba(124, 58, 237, 0.3);
}

#relicsList::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #8b5cf6, #a78bfa);
    box-shadow: 0 0 8px rgba(124, 58, 237, 0.5);
}

/* Firefox Scrollbar */
#relicsList {
    scrollbar-width: thin;
    scrollbar-color: #7c3aed rgba(0, 0, 0, 0.2);
}

.relic {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 10px;
    border-left: 4px solid #7c3aed;
}

.relic-name {
    font-weight: bold;
    color: #ffd43b;
    margin-bottom: 5px;
}

.relic-desc {
    font-size: 12px;
    color: #b0b0b0;
}

.relic-options {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 20px;
}

.relic-option {
    background: linear-gradient(135deg, rgba(124, 58, 237, 0.2), rgba(147, 51, 234, 0.3));
    border: 2px solid rgba(124, 58, 237, 0.5);
    border-radius: 12px;
    padding: 20px;
    color: white;
    font-family: 'Orbitron', monospace;
    cursor: pointer;
    transition: all 0.3s;
    text-align: left;
}

.relic-option:hover {
    border-color: rgba(124, 58, 237, 0.8);
    background: linear-gradient(135deg, rgba(124, 58, 237, 0.3), rgba(147, 51, 234, 0.4));
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(124, 58, 237, 0.3);
}

.relic-option-name {
    font-size: 16px;
    font-weight: bold;
    color: #ffd43b;
    margin-bottom: 8px;
}

.relic-option-desc {
    font-size: 14px;
    color: #e0e0e0;
    line-height: 1.4;
}

.combo-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    font-weight: bold;
    color: #ffd43b;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    pointer-events: none;
    opacity: 0;
    z-index: 100;
}

.combo-indicator.show {
    animation: comboPopup 1s ease-out;
}

@keyframes comboPopup {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
}

.title {
    text-align: center;
    font-size: 28px;
    font-weight: 900;
    color: #7c3aed;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    margin-bottom: 20px;
}

.game-over {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    border: 3px solid #7c3aed;
    display: none;
    z-index: 1000;
}

.btn {
    background: linear-gradient(135deg, #7c3aed, #9775fa);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    margin: 10px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(124, 58, 237, 0.4);
}

.start-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(124, 58, 237, 0.2));
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.start-title {
    font-size: 72px;
    font-weight: 900;
    background: linear-gradient(45deg, #7c3aed, #ffd43b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    margin-bottom: 30px;
    animation: titleGlow 3s ease-in-out infinite;
}

@keyframes titleGlow {
    0%, 100% { filter: drop-shadow(0 0 10px rgba(124, 58, 237, 0.5)); }
    50% { filter: drop-shadow(0 0 30px rgba(255, 212, 59, 0.7)); }
}

.start-subtitle {
    font-size: 24px;
    color: #e0e0e0;
    margin-bottom: 50px;
    text-align: center;
}

.btn-start {
    background: linear-gradient(135deg, #7c3aed, #9775fa);
    color: white;
    border: none;
    padding: 20px 40px;
    border-radius: 12px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 5px 20px rgba(124, 58, 237, 0.3);
}

.btn-start:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(124, 58, 237, 0.5);
}

.game-rules {
    max-width: 600px;
    margin: 30px;
    padding: 30px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(124, 58, 237, 0.3);
}

.rules-title {
    font-size: 20px;
    color: #ffd43b;
    margin-bottom: 15px;
    text-align: center;
}

.rules-text {
    font-size: 14px;
    line-height: 1.6;
    color: #b0b0b0;
    text-align: left;
}

.gem-value-display {
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 10px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.7);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Score Display - Now directly in stats panel */
.score-display {
    font-size: 32px;
    font-weight: bold;
    color: #ffd43b;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    text-align: center;
    margin: 10px 0;
    transition: all 0.3s ease;
    position: relative;
    overflow: visible;
}

/* Professional "kablaam" animation - subtle scale and glow */
.score-display.kablaam {
    animation: professionalKablaam 0.8s ease-out;
}

@keyframes professionalKablaam {
    0% { 
        transform: scale(1); 
        filter: brightness(1) drop-shadow(0 0 5px rgba(255, 212, 59, 0.3));
    }
    30% { 
        transform: scale(1.15); 
        filter: brightness(1.3) drop-shadow(0 0 15px rgba(255, 212, 59, 0.6));
    }
    60% { 
        transform: scale(1.08); 
        filter: brightness(1.1) drop-shadow(0 0 10px rgba(255, 212, 59, 0.4));
    }
    100% { 
        transform: scale(1); 
        filter: brightness(1) drop-shadow(0 0 5px rgba(255, 212, 59, 0.3));
    }
}

/* Professional "wibble" animation - gentle oscillation */
.score-display.wibble {
    animation: professionalWibble 0.6s ease-in-out;
}

@keyframes professionalWibble {
    0% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.05) rotate(1deg); }
    50% { transform: scale(1.08) rotate(0deg); }
    75% { transform: scale(1.05) rotate(-1deg); }
    100% { transform: scale(1) rotate(0deg); }
}

/* Combo display below score */
.combo-display {
    font-size: 14px;
    font-weight: bold;
    color: #ff6b6b;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    text-align: center;
    opacity: 0;
    transition: all 0.3s ease;
    margin-bottom: 10px;
}

.combo-display.show {
    opacity: 1;
}

/* Score Popup - Appears from top right */
.score-popup {
    position: fixed;
    font-size: 24px;
    font-weight: 900;
    color: #ffd43b;
    text-shadow: 
        2px 2px 0px rgba(0, 0, 0, 0.8),
        0 0 10px rgba(255, 212, 59, 0.8);
    opacity: 0;
    transform: scale(0.8);
    z-index: 9999;
    pointer-events: none;
    white-space: nowrap;
}

.score-popup.animate {
    animation: scorePopupAnimationFixed 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes scorePopupAnimationFixed {
    0% {
        opacity: 0;
        transform: translate(0, 0) scale(0.8);
    }
    20% {
        opacity: 1;
        transform: translate(30px, -30px) scale(1.2);
    }
    50% {
        opacity: 1;
        transform: translate(60px, -60px) scale(1.0);
    }
    80% {
        opacity: 0.7;
        transform: translate(90px, -90px) scale(0.9);
    }
    100% {
        opacity: 0;
        transform: translate(120px, -120px) scale(0.8);
    }
}

.game-board-container {
    position: relative;
}

/* Continue Button */
.continue-option {
    background: linear-gradient(135deg, #51cf66, #37b24d);
    border: 2px solid rgba(81, 207, 102, 0.5);
}

.continue-option:hover {
    border-color: rgba(81, 207, 102, 0.8);
    background: linear-gradient(135deg, rgba(81, 207, 102, 0.3), rgba(55, 178, 77, 0.4));
}

.continue-option .relic-option-name {
    color: #51cf66;
}

.gem.lightning-strike {
    animation: lightningStrike 0.8s ease-out;
    box-shadow: 0 0 25px #ffd43b, 0 0 50px #fab005;
}

@keyframes lightningStrike {
    0% { 
        transform: scale(1); 
        filter: brightness(1);
    }
    30% { 
        transform: scale(1.2); 
        filter: brightness(2) saturate(1.5);
    }
    60% { 
        transform: scale(1.1); 
        filter: brightness(1.5) saturate(1.2);
    }
    100% { 
        transform: scale(1); 
        filter: brightness(1);
    }
}

.gem.lightning.thunderbolt {
    border-color: gold;
    box-shadow: 0 0 20px #ffd43b;
    font-weight: 900;
}

@keyframes jesterGambit {
0%   { filter: hue-rotate(0deg) scale(1); }
50%  { filter: hue-rotate(180deg) scale(1.1); }
100% { filter: hue-rotate(360deg) scale(1); }
}
.jester-effect {
animation: jesterGambit 3s ease-in-out infinite;
}
@keyframes quantumMirror {
0%   { transform: perspective(400px) rotateY(0deg); opacity: 0.8; }
50%  { transform: perspective(400px) rotateY(180deg); opacity: 1; }
100% { transform: perspective(400px) rotateY(360deg); opacity: 0.8; }
}
.quantum-mirror-effect {
animation: quantumMirror 4s linear infinite;
}
@keyframes entropySurge {
0%   { box-shadow: 0 0 5px #fff; }
50%  { box-shadow: 0 0 25px #ff4080; }
100% { box-shadow: 0 0 5px #fff; }
}
.entropy-engine-effect {
animation: entropySurge 2s ease-in-out infinite;
border-color: #ff4080;
}

/* Jester‚Äôs Gambit: wave spin and fall */
@keyframes jesterFall {
0%   { transform: rotateZ(0deg) translateY(0);    opacity: 1; }
50%  { transform: rotateZ(180deg) translateY(50vh); opacity: 0.7; }
100% { transform: rotateZ(360deg) translateY(100vh); opacity: 0; }
}
.jester-fall {
animation: jesterFall 0.8s ease-in-out forwards;
}

.shuffle-move {
transition: transform 0.6s ease-out;
}

@keyframes selectedPulse {
    0%, 100% { 
        box-shadow: 
            0 0 25px rgba(255, 255, 255, 0.8),
            0 0 40px rgba(124, 58, 237, 0.6),
            inset 0 0 15px rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.9);
    }
    50% { 
        box-shadow: 
            0 0 35px rgba(255, 255, 255, 1),
            0 0 60px rgba(124, 58, 237, 0.8),
            inset 0 0 20px rgba(255, 255, 255, 0.5);
        border-color: rgba(255, 255, 255, 1);
    }
}

/* Crystal Display */
.crystal-display {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin: 10px 0;
    padding: 8px 12px;
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(167, 139, 250, 0.3));
    border: 1px solid rgba(139, 92, 246, 0.5);
    border-radius: 8px;
}

.crystal-icon {
    font-size: 18px;
    filter: drop-shadow(0 0 4px rgba(139, 92, 246, 0.8));
}

.crystal-amount {
    font-size: 16px;
    font-weight: bold;
    color: #8b5cf6;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Shop Styles */
.shop-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: none;
    z-index: 3000;
    overflow-y: auto;
}

.shop-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 40px 20px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.shop-header {
    text-align: center;
    margin-bottom: 40px;
}

.shop-title {
    font-size: 48px;
    font-weight: 900;
    background: linear-gradient(45deg, #8b5cf6, #ffd43b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 20px;
}

.shop-crystal-display {
    display: inline-flex;
    align-items: center;
    gap: 12px;
    padding: 12px 24px;
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(167, 139, 250, 0.4));
    border: 2px solid rgba(139, 92, 246, 0.6);
    border-radius: 12px;
    font-size: 24px;
    font-weight: bold;
    color: #8b5cf6;
    margin-bottom: 20px;
}

.shop-tabs {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 30px;
    flex-wrap: wrap;
}

.shop-tab {
    background: rgba(124, 58, 237, 0.2);
    border: 2px solid rgba(124, 58, 237, 0.4);
    color: #e0e0e0;
    padding: 12px 20px;
    border-radius: 8px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 14px;
}

.shop-tab:hover {
    border-color: rgba(124, 58, 237, 0.6);
    background: rgba(124, 58, 237, 0.3);
}

.shop-tab.active {
    background: linear-gradient(135deg, #7c3aed, #9775fa);
    border-color: #7c3aed;
    color: white;
    box-shadow: 0 0 15px rgba(124, 58, 237, 0.5);
}

.shop-content {
    flex: 1;
}

.shop-category {
    display: none;
}

.shop-category.active {
    display: block;
}

.shop-items {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.shop-item {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(124, 58, 237, 0.1));
    border: 2px solid rgba(124, 58, 237, 0.3);
    border-radius: 15px;
    padding: 20px;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
}

.shop-item:hover {
    border-color: rgba(124, 58, 237, 0.6);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(124, 58, 237, 0.3);
}

.shop-item.owned {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1));
    border-color: rgba(34, 197, 94, 0.5);
}

.shop-item.owned::before {
    content: "‚úì OWNED";
    position: absolute;
    top: 10px;
    right: 15px;
    background: rgba(34, 197, 94, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: bold;
}

.shop-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 15px;
}

.shop-item-name {
    font-size: 18px;
    font-weight: bold;
    color: #ffd43b;
    margin-bottom: 5px;
}

.shop-item-type {
    font-size: 12px;
    color: #8b5cf6;
    text-transform: uppercase;
    font-weight: bold;
}

.shop-item-price {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 16px;
    font-weight: bold;
    color: #8b5cf6;
}

.shop-item-desc {
    color: #e0e0e0;
    line-height: 1.5;
    margin-bottom: 15px;
    font-size: 14px;
}

.shop-item-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.shop-item-quantity {
    font-size: 12px;
    color: #9ca3af;
}

.shop-buy-btn {
    background: linear-gradient(135deg, #8b5cf6, #a78bfa);
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 6px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 12px;
}

.shop-buy-btn:hover {
    background: linear-gradient(135deg, #7c3aed, #8b5cf6);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
}

.shop-buy-btn:disabled {
    background: rgba(107, 114, 128, 0.5);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.shop-close-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(239, 68, 68, 0.8);
    border: none;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 3001;
}

.shop-close-btn:hover {
    background: rgba(239, 68, 68, 1);
    transform: scale(1.1);
}

/* Rarity Colors */
.shop-item.common { border-left: 4px solid #10b981; }
.shop-item.rare { border-left: 4px solid #3b82f6; }
.shop-item.epic { border-left: 4px solid #8b5cf6; }
.shop-item.legendary { border-left: 4px solid #f59e0b; }

/* Purchase Confirmation */
.purchase-confirmation {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    border: 3px solid #8b5cf6;
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    z-index: 4000;
    display: none;
}

.confirmation-title {
    font-size: 24px;
    color: #ffd43b;
    margin-bottom: 15px;
}

.confirmation-text {
    color: #e0e0e0;
    margin-bottom: 20px;
    line-height: 1.5;
}

.confirmation-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.confirm-btn {
    background: linear-gradient(135deg, #10b981, #059669);
    border: none;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
}

.cancel-btn {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    border: none;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
}

.confirm-btn:hover, .cancel-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

/* Crystal Gain Animation */
.crystal-gain {
    position: fixed;
    font-size: 28px;
    font-weight: 900;
    color: #8b5cf6;
    text-shadow: 
        2px 2px 0px rgba(0, 0, 0, 0.8),
        0 0 15px rgba(139, 92, 246, 0.8);
    opacity: 0;
    transform: scale(0.8);
    z-index: 9999;
    pointer-events: none;
    white-space: nowrap;
}

.crystal-gain.animate {
    animation: crystalGainAnimation 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

@keyframes crystalGainAnimation {
    0% {
        opacity: 0;
        transform: translate(0, 0) scale(0.8);
    }
    20% {
        opacity: 1;
        transform: translate(0, -40px) scale(1.3);
    }
    50% {
        opacity: 1;
        transform: translate(0, -80px) scale(1.1);
    }
    80% {
        opacity: 0.7;
        transform: translate(0, -120px) scale(1.0);
    }
    100% {
        opacity: 0;
        transform: translate(0, -160px) scale(0.9);
    }
}

/* Consumables Panel */
.consumables-panel {
    background: rgba(139, 92, 246, 0.1);
    padding: 15px;
    border-radius: 10px;
    border: 1px solid rgba(139, 92, 246, 0.3);
    margin: 10px 0;
}

.consumable-btn {
    background: linear-gradient(135deg, #8b5cf6, #a78bfa);
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 11px;
    margin: 2px;
    display: inline-block;
    position: relative;
}

.consumable-btn:hover {
    background: linear-gradient(135deg, #7c3aed, #8b5cf6);
    transform: translateY(-1px);
}

.consumable-btn:disabled {
    background: rgba(107, 114, 128, 0.5);
    cursor: not-allowed;
    transform: none;
}

.consumable-count {
    position: absolute;
    top: -5px;
    right: -5px;
    background: #ef4444;
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

/* Available Boosters Panel */
.available-boosters-panel {
    background: rgba(139, 92, 246, 0.1);
    padding: 15px;
    border-radius: 10px;
    border: 1px solid rgba(139, 92, 246, 0.3);
    margin: 10px 0;
}

.booster-btn {
    background: linear-gradient(135deg, #8b5cf6, #a78bfa);
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 11px;
    margin: 2px;
    display: inline-block;
    position: relative;
    width: 100%;
    margin-bottom: 5px;
    text-align: left;
}

.booster-btn:hover {
    background: linear-gradient(135deg, #7c3aed, #8b5cf6);
    transform: translateY(-1px);
}

.booster-btn:disabled {
    background: rgba(107, 114, 128, 0.5);
    cursor: not-allowed;
    transform: none;
}

.booster-count {
    position: absolute;
    top: -5px;
    right: -5px;
    background: #10b981;
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.booster-description {
    font-size: 9px;
    opacity: 0.8;
    margin-top: 2px;
}

/* Boosters Panel */
.boosters-panel {
    background: rgba(16, 185, 129, 0.1);
    padding: 15px;
    border-radius: 10px;
    border: 1px solid rgba(16, 185, 129, 0.3);
    margin: 10px 0;
}

.active-booster {
    background: rgba(16, 185, 129, 0.2);
    padding: 8px;
    border-radius: 6px;
    margin-bottom: 8px;
    border-left: 3px solid #10b981;
    font-size: 12px;
}

.booster-name {
    font-weight: bold;
    color: #10b981;
    margin-bottom: 3px;
}

.booster-desc {
    color: #e0e0e0;
    font-size: 10px;
}

/* Cosmetic Themes */
.gem.neon-theme.fire { 
    background: linear-gradient(135deg, #ff0080, #ff4da6); 
    box-shadow: 0 0 15px #ff0080;
}
.gem.neon-theme.ice { 
    background: linear-gradient(135deg, #00ffff, #4dffff); 
    box-shadow: 0 0 15px #00ffff;
}
.gem.neon-theme.nature { 
    background: linear-gradient(135deg, #00ff00, #4dff4d); 
    box-shadow: 0 0 15px #00ff00;
}
.gem.neon-theme.lightning { 
    background: linear-gradient(135deg, #ffff00, #ffff4d); 
    box-shadow: 0 0 15px #ffff00;
}
.gem.neon-theme.void { 
    background: linear-gradient(135deg, #8000ff, #a64dff); 
    box-shadow: 0 0 15px #8000ff;
}

.game-board.space-theme {
    background: radial-gradient(circle at center, rgba(30, 30, 126, 0.8), rgba(0, 0, 0, 0.9));
    border: 2px solid rgba(139, 92, 246, 0.6);
    box-shadow: 
        0 0 30px rgba(139, 92, 246, 0.4),
        inset 0 0 50px rgba(30, 30, 126, 0.3);
}

.enhanced-particles {
  position: absolute;
  top:0; left:0;
  width:100vw; height:100vh;
  pointer-events:none;
  z-index: 99;
}

.particle {
  position: absolute;
  border-radius: 50%;
  opacity: 1;
  /* start small & bright */
  width: var(--size, 6px);
  height: var(--size, 6px);
  background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 80%);
  filter: drop-shadow(0 0 10px rgba(255,255,255,0.8));
  animation: flashParticle var(--duration, 800ms) ease-out forwards;
}

@keyframes flashParticle {
  0% {
    transform: translate(0,0) scale(0.5);
    opacity: 1;
  }
  30% {
    transform: translate(var(--dx), var(--dy)) scale(1.2);
    opacity: 0.9;
  }
  60% {
    transform: translate(calc(var(--dx)*1.2), calc(var(--dy)*1.2)) scale(0.8);
    opacity: 0.6;
  }
  100% {
    transform: translate(calc(var(--dx)*1.5), calc(var(--dy)*1.5)) scale(0.2);
    opacity: 0;
  }
}

/* üåü Star‚Äêshaped sparkle */
.sparkle-particle {
  position: absolute;
  --star-size: 12px; /* default size */
  width: var(--size, var(--star-size));
  height: var(--size, var(--star-size));
  background: white;
  /* 5-point star clip-path */
  clip-path: polygon(
    50% 0%,  61% 35%,  98% 35%,  68% 57%,
    79% 91%, 50% 70%, 21% 91%, 32% 57%,
    2% 35%, 39% 35%
  );
  filter:
    drop-shadow(0 0 6px rgba(255,255,255,0.9))
    drop-shadow(0 0 14px rgba(173,216,230,0.7));
  animation: sparkle-anim var(--duration, 700ms) ease-out forwards;
  z-index: 100;
}

@keyframes sparkle-anim {
  0% {
    transform: translate(0,0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--dx), var(--dy)) scale(0.2);
    opacity: 0;
  }
}

@keyframes particleFloat {
    0% { 
        opacity: 1; 
        transform: scale(1) translate(0, 0); 
    }
    100% { 
        opacity: 0; 
        transform: scale(0.3) translate(var(--dx), var(--dy)); 
    }
}

/* Audio Permission Screen */
.audio-permission-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(124, 58, 237, 0.3));
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 5000;
}

.audio-permission-container {
    text-align: center;
    padding: 50px;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 20px;
    border: 3px solid #7c3aed;
    box-shadow: 0 0 50px rgba(124, 58, 237, 0.5);
    max-width: 700px; /* Increase this if needed */
    width: 90%; /* Add this to make it responsive */
    margin: 0 auto; /* Center the container */
}

.audio-permission-title {
    font-size: 48px;
    font-weight: 900;
    background: linear-gradient(45deg, #7c3aed, #ffd43b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 20px;
    animation: titleGlow 3s ease-in-out infinite;
    white-space: nowrap; /* Add this line to prevent wrapping */
}

.audio-permission-text {
    font-size: 24px;
    color: #e0e0e0;
    margin-bottom: 10px;
    font-weight: bold;
}

.audio-permission-subtext {
    font-size: 16px;
    color: #b0b0b0;
    margin-bottom: 40px;
}

.audio-permission-buttons {
    display: flex;
    gap: 20px;
    justify-content: center;
    flex-wrap: wrap;
}

.audio-btn {
    padding: 15px 30px;
    border: none;
    border-radius: 12px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 180px;
}

.audio-btn-yes {
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    box-shadow: 0 5px 20px rgba(16, 185, 129, 0.3);
}

.audio-btn-yes:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(16, 185, 129, 0.5);
}

.audio-btn-no {
    background: linear-gradient(135deg, #6b7280, #4b5563);
    color: white;
    box-shadow: 0 5px 20px rgba(107, 114, 128, 0.3);
}

.audio-btn-no:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(107, 114, 128, 0.5);
}

/* Options Menu Styles */
.options-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: none;
    z-index: 4000;
    overflow-y: auto;
}

.options-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 40px 20px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.options-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    border-bottom: 2px solid rgba(124, 58, 237, 0.3);
    padding-bottom: 20px;
}

.options-title {
    font-size: 32px;
    font-weight: 900;
    background: linear-gradient(45deg, #7c3aed, #ffd43b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin: 0;
}

.options-close-btn {
    background: rgba(239, 68, 68, 0.8);
    border: none;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s;
}

.options-close-btn:hover {
    background: rgba(239, 68, 68, 1);
    transform: scale(1.1);
}

.options-content {
    flex: 1;
}

.options-section {
    background: rgba(124, 58, 237, 0.1);
    border: 1px solid rgba(124, 58, 237, 0.3);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
}

.options-section-title {
    font-size: 20px;
    font-weight: bold;
    color: #ffd43b;
    margin-bottom: 15px;
    border-bottom: 1px solid rgba(255, 212, 59, 0.3);
    padding-bottom: 10px;
}

.cosmetic-option, .setting-option {
    margin-bottom: 15px;
}

.cosmetic-label, .setting-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: #e0e0e0;
    font-weight: bold;
    cursor: pointer;
}

.cosmetic-select {
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(124, 58, 237, 0.5);
    border-radius: 6px;
    color: #e0e0e0;
    padding: 8px 12px;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    cursor: pointer;
    min-width: 150px;
}

.cosmetic-select:focus {
    border-color: #7c3aed;
    outline: none;
    box-shadow: 0 0 10px rgba(124, 58, 237, 0.3);
}

.cosmetic-select option {
    background: #1a1a1a;
    color: #e0e0e0;
}

.cosmetic-select option:disabled {
    color: #666;
}

.audio-controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.volume-label {
    display: flex;
    align-items: center;
    gap: 15px;
    color: #e0e0e0;
    font-weight: bold;
}

.volume-slider {
    flex: 1;
    height: 6px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
}

.volume-slider::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    background: linear-gradient(135deg, #7c3aed, #9775fa);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
}

.volume-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: linear-gradient(135deg, #7c3aed, #9775fa);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
}

.setting-label input[type="checkbox"] {
    margin-right: 10px;
    transform: scale(1.2);
    accent-color: #7c3aed;
}

.options-footer {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 30px;
    padding-top: 20px;
    border-top: 2px solid rgba(124, 58, 237, 0.3);
}

.btn-secondary {
    background: linear-gradient(135deg, #6b7280, #4b5563);
    color: white;
}

.btn-secondary:hover {
    background: linear-gradient(135deg, #4b5563, #374151);
}

.options-btn {
    background: linear-gradient(135deg, #059669, #047857);
    border: none;
}

.options-btn:hover {
    background: linear-gradient(135deg, #047857, #065f46);
}

/* Disabled cosmetic options */
.cosmetic-select option[disabled] {
    color: #666;
    font-style: italic;
}

.cosmetic-select option[disabled]::after {
    content: " (Not Owned)";
}

/* In-Game Audio Toggle */
.ingame-audio-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid rgba(124, 58, 237, 0.5);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: white;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 1001;
    display: none; /* This should change to 'flex' when shown */
    align-items: center;
    justify-content: center;
    pointer-events: auto; /* Make sure this isn't 'none' */
}

.ingame-audio-toggle:hover {
    transform: scale(1.1);
    border-color: rgba(124, 58, 237, 0.8);
    box-shadow: 0 0 15px rgba(124, 58, 237, 0.4);
}

.ingame-audio-toggle.audio-enabled {
    background: rgba(16, 185, 129, 0.8);
    border-color: rgba(16, 185, 129, 0.5);
}

.ingame-audio-toggle.audio-enabled:hover {
    border-color: rgba(16, 185, 129, 0.8);
    box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
}
.gem-selection-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    border: 3px solid #8b5cf6;
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    z-index: 4000;
    display: none;
}

.gem-selection-title {
    font-size: 24px;
    color: #ffd43b;
    margin-bottom: 20px;
}

.gem-type-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
}

/* Gem Selection Modal */
.gem-selection-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    border: 3px solid #8b5cf6;
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    z-index: 5000;
    display: none;
}

.gem-selection-title {
    font-size: 24px;
    color: #ffd43b;
    margin-bottom: 20px;
}

.gem-type-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
}

.gem-type-btn {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: all 0.3s;
    position: relative;
    z-index: 5001;
}

.gem-type-btn:hover {
    transform: scale(1.1);
    border-color: rgba(255, 255, 255, 0.8);
    z-index: 5002;
}

/* Gem type button colors */
.gem-type-btn.fire { 
    background: linear-gradient(135deg, #ff6b6b, #ff8787); 
    color: #fff; 
}

.gem-type-btn.ice { 
    background: linear-gradient(135deg, #74c0fc, #339af0); 
    color: #fff; 
}

.gem-type-btn.nature { 
    background: linear-gradient(135deg, #51cf66, #37b24d); 
    color: #fff; 
}

.gem-type-btn.lightning { 
    background: linear-gradient(135deg, #ffd43b, #fab005); 
    color: #000; 
}

.gem-type-btn.void { 
    background: linear-gradient(135deg, #9775fa, #7c3aed); 
    color: #fff; 
}

/* Mobile Responsive CSS for Gemspire */

/* ‚îÄ‚îÄ‚îÄ PORTRAIT: Board ‚Üí Stats ‚Üí Active Relics ‚Üí Others ‚îÄ‚îÄ‚îÄ */
@media screen and (max-width: 768px) and (orientation: portrait) {
  .game-container {
    flex-direction: column;
    overflow-x: hidden;
    padding: 5px;              /* tighten up mobile padding */
  }

  /* 1) Board wrapper (use your existing .game-board-container) */
  .game-board-container {
    order: 1;
    width: calc(100vw - 20px);
    max-width: 400px;
    height: auto;
    margin: 0 auto 8px;
  }

  /* 2) Sidebar grouping */
  .ui-panel {
    order: 2;
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: none;
    gap: 8px;
    padding: 0 10px;
    box-sizing: border-box;
  }

  /* 2a) Stats panel */
  .ui-panel .stats-panel {
    order: 1;
    width: 100%;
    margin: 0 auto;
    box-sizing: border-box;
  }

  /* 2b) Active relics */
  .ui-panel .active-relics-container {
    order: 2;
    width: 100%;
    margin: 0 auto;
    box-sizing: border-box;
  }

  /* 2c) Consumables / Boosters */
  .ui-panel .consumables-panel,
  .ui-panel .boosters-panel,
  .ui-panel .available-boosters-panel {
    order: 3;
    width: 100%;
    margin: 0 auto;
    box-sizing: border-box;
  }
}

/* ‚îÄ‚îÄ‚îÄ LANDSCAPE: Two-column like desktop ‚îÄ‚îÄ‚îÄ */
@media screen and (max-width: 768px) and (orientation: landscape) {
  .game-container {
    flex-direction: row;
    justify-content: space-between;
    padding: 5px;
  }

  /* Left: board */
  .game-board-container {
    order: 1;
    flex: 0 0 60%;
    max-width: 60%;
    margin-right: 10px;
  }

  /* Right: sidebar */
  .ui-panel {
    order: 2;
    flex: 1;
    max-width: 40%;
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 0 10px;
    box-sizing: border-box;
    overflow-y: auto;
  }

  /* Stats on top */
  .ui-panel .stats-panel {
    order: 1;
    width: 100%;
  }

  /* Active relics under stats */
  .ui-panel .active-relics-container {
    order: 2;
    width: 100%;
  }

  /* Then consumables / boosters */
  .ui-panel .consumables-panel,
  .ui-panel .boosters-panel,
  .ui-panel .available-boosters-panel {
    order: 3;
    width: 100%;
  }
}

/* ‚îÄ‚îÄ‚îÄ prevent ANY horizontal overflow ‚îÄ‚îÄ‚îÄ */
html, body, .game-container {
  overflow-x: hidden !important;
}

/* ‚îÄ‚îÄ‚îÄ PORTRAIT: clamp widths to 100vw ‚îÄ‚îÄ‚îÄ */
@media screen and (max-width: 768px) and (orientation: portrait) {
  .game-board-container,
  .ui-panel {
    width: 100vw !important;
    max-width: 100vw !important;
    padding: 0 5px !important;
    box-sizing: border-box !important;
  }
  .game-board-container .game-board {
    width: 100% !important;
    height: auto !important;
    max-width: none !important;
  }
  .ui-panel .active-relics-container {
    width: 100% !important;
    max-width: none !important;
    padding: 0 5px !important;
  }
}

/* ‚îÄ‚îÄ‚îÄ LANDSCAPE: adjust flex proportions ‚îÄ‚îÄ‚îÄ */
@media screen and (max-width: 768px) and (orientation: landscape) {
  .game-board-container {
    flex: 0 0 55% !important;
    max-width: 55% !important;
  }
  .ui-panel {
    flex: 0 0 45% !important;
    max-width: 45% !important;
  }
}

</style>
</head>
<body>
    <div class="bg-animation" id="bgAnimation"></div>

    <div class="audio-permission-screen" id="audioPermissionScreen">
        <div class="audio-permission-container">
            <div class="audio-permission-title">üéµ GEMSPIRE üéµ</div>
            <div class="audio-permission-text">Would you like to enable audio?</div>
            <div class="audio-permission-subtext">Includes background music and sound effects</div>
            <div class="audio-permission-buttons">
                <button class="audio-btn audio-btn-yes" onclick="enableAudioAndStart()">
                    üîä Yes, Enable Audio
                </button>
                <button class="audio-btn audio-btn-no" onclick="disableAudioAndStart()">
                    üîá No, Play Silently
                </button>
            </div>
        </div>
    </div>

    <div class="start-screen" id="startScreen" style="display: none;">
        <div class="start-title">‚ö° GEMSPIRE ‚ö°</div>
        <div class="start-subtitle">A mystical match-3 roguelike adventure</div>
        <button class="btn-start" onclick="startGame()">Begin Your Journey</button>

        <div class="game-rules">
            <div class="rules-title">How to Play</div>
            <div class="rules-text">
                ‚Ä¢ Match 3+ gems by swapping adjacent pieces<br>
                ‚Ä¢ Score points to reach the target and advance floors<br>
                ‚Ä¢ Each floor increases difficulty but offers powerful relics<br>
                ‚Ä¢ Special gems (50+ value) glow with power<br>
                ‚Ä¢ Chain matches for bonus multipliers<br>
                ‚Ä¢ Survive as many floors as you can!
            </div>
        </div>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div>
            <h1 class="title">‚ö° GEMSPIRE ‚ö°</h1>
            <div class="game-board-container">
                <div class="game-board" id="gameBoard"></div>
            </div>
            <div class="combo-indicator" id="comboIndicator"></div>

			<div class="active-relics-container">
			  <h4>Active Relics</h4>
			  <div class="active-relics-grid" id="relicsList">
				<!-- relic items go here -->
			  </div>
			</div>
        </div>

        <div class="ui-panel">
			<div class="stats-panel">
				<div class="floor-info">Floor <span id="currentFloor">1</span></div>
				<div class="moves-left">Moves: <span id="movesLeft">4</span></div>
				<div class="progress-bar">
					<div class="progress-fill" id="progressFill" style="width: 0%"></div>
				</div>
				
				<!-- Score display directly in stats panel -->
				<div class="score-display" id="scoreDisplay">0</div>
				<div class="combo-display" id="comboDisplay">Combo x1</div>
				
				<!-- Crystal Display -->
				<div class="crystal-display">
					<span class="crystal-icon">üíé</span>
					<span class="crystal-amount" id="crystalAmount">0</span>
				</div>

				<!-- Moved: Target Score & Multiplier below crystals, above options -->
				<div class="stat-item">
					<span>Target:</span>
					<span class="stat-value" id="targetScore">800</span>
				</div>
				<div class="stat-item">
					<span>Multiplier:</span>
					<span class="stat-value" id="multiplier">1.0x</span>
				</div>

				<!-- Options Button -->
				<button class="btn options-btn" onclick="openOptionsMenu()" style="width: 100%; margin: 10px 0; font-size: 14px;">
					‚öôÔ∏è Options
				</button>

				<!-- Consumable Usage Panel -->
				<div class="consumables-panel" id="consumablesPanel" style="display: none;">
					<h4 style="color: #8b5cf6; margin-bottom: 10px; font-size: 14px;">üí´ Consumables</h4>
					<div id="consumableButtons"></div>
				</div>

				<!-- Active Boosters Display -->
				<div class="boosters-panel" id="boostersPanel" style="display: none;">
					<h4 style="color: #10b981; margin-bottom: 10px; font-size: 14px;">‚ö° Active Boosters</h4>
					<div id="activeBoostersList"></div>
				</div>

				<!-- Available Boosters Panel -->
				<div class="available-boosters-panel" id="availableBoostersPanel" style="display: none;">
					<h4 style="color: #8b5cf6; margin-bottom: 10px; font-size: 14px;">üí´ Available Boosters</h4>
					<div id="availableBoosterButtons"></div>
				</div>

			</div>
            
        </div>
    </div>

    <div class="game-over" id="relicSelectionScreen">
        <h2>Choose Your Relic</h2>
        <p>Select one upgrade to help you on your journey:</p>
        <div id="relicOptions" class="relic-options"></div>
    </div>

    <div class="game-over" id="gameOverScreen">
        <h2>Game Over!</h2>
        <p id="floorResult">Game Over</p>
        <button class="btn" onclick="restartGame()">Restart</button>
        <button class="btn" onclick="returnToStart()">Main Menu</button>
    </div>

    <!-- Shop Screen -->
    <div class="shop-screen" id="shopScreen">
        <button class="shop-close-btn" onclick="closeShop()">√ó</button>
        <div class="shop-container">
            <div class="shop-header">
                <div class="shop-title">üè™ ARCANE EMPORIUM</div>
                <div class="shop-crystal-display">
                    <span class="crystal-icon">üíé</span>
                    <span id="shopCrystalAmount">0</span>
                    <span>Arcane Crystals</span>
                </div>
                <p style="color: #b0b0b0; margin-top: 10px;">Spend your crystals wisely to enhance your power!</p>
            </div>

            <div class="shop-tabs">
                <button class="shop-tab active" onclick="switchShopTab('permanent')">üîÆ Permanent</button>
                <button class="shop-tab" onclick="switchShopTab('boosters')">‚ö° Boosters</button>
                <button class="shop-tab" onclick="switchShopTab('consumables')">üéØ Consumables</button>
                <button class="shop-tab" onclick="switchShopTab('prestige')">üåü Prestige</button>
                <button class="shop-tab" onclick="switchShopTab('cosmetics')">üé® Cosmetics</button>
            </div>

            <div class="shop-content">
                <div class="shop-category active" id="permanent">
                    <div class="shop-items" id="permanentItems"></div>
                </div>
                <div class="shop-category" id="boosters">
                    <div class="shop-items" id="boostersItems"></div>
                </div>
                <div class="shop-category" id="consumables">
                    <div class="shop-items" id="consumablesItems"></div>
                </div>
                <div class="shop-category" id="prestige">
                    <div class="shop-items" id="prestigeItems"></div>
                </div>
                <div class="shop-category" id="cosmetics">
                    <div class="shop-items" id="cosmeticsItems"></div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="closeShop()">Continue Journey</button>
            </div>
        </div>
    </div>

    <!-- In-Game Audio Toggle -->
	<button class="ingame-audio-toggle" id="ingameAudioToggle" onclick="window.game.toggleIngameAudio()">
		üîá
	</button>

    <!-- Options Menu -->
    <div class="options-screen" id="optionsScreen">
        <div class="options-container">
            <div class="options-header">
                <h2 class="options-title">‚öôÔ∏è Game Options</h2>
                <button class="options-close-btn" onclick="closeOptionsMenu()">√ó</button>
            </div>
            
            <div class="options-content">
                <!-- Cosmetics Section -->
                <div class="options-section">
                    <h3 class="options-section-title">üé® Cosmetics</h3>
                    
                    <div class="cosmetic-option">
                        <label class="cosmetic-label">
                            üíé Gem Theme:
                            <select class="cosmetic-select" id="gemThemeSelect" onchange="changeGemTheme()">
                                <option value="default">Classic</option>
                                <option value="neon">Neon (Premium)</option>
                            </select>
                        </label>
                    </div>
                    
                    <div class="cosmetic-option">
                        <label class="cosmetic-label">
                            üåå Board Theme:
                            <select class="cosmetic-select" id="boardThemeSelect" onchange="changeBoardTheme()">
                                <option value="default">Classic</option>
                                <option value="space">Space (Premium)</option>
                            </select>
                        </label>
                    </div>
                    
                    <div class="cosmetic-option">
                        <label class="cosmetic-label">
                            ‚ú® Particle Effects:
                            <select class="cosmetic-select" id="particleEffectsSelect" onchange="changeParticleEffects()">
                                <option value="false">Disabled</option>
                                <option value="true">Enhanced (Premium)</option>
                            </select>
                        </label>
                    </div>
                </div>
                
                <!-- Audio Section -->
                <div class="options-section">
                    <h3 class="options-section-title">üîä Audio</h3>
                    
                    <div class="audio-controls">
                        <label class="volume-label">
                            üéµ Music Volume:
                            <input type="range" class="volume-slider" id="musicVolumeSlider" 
                                   min="0" max="100" value="30" onchange="changeMusicVolume()">
                            <span id="musicVolumeValue">30%</span>
                        </label>
                        
                        <label class="volume-label">
                            üîä SFX Volume:
                            <input type="range" class="volume-slider" id="sfxVolumeSlider" 
                                   min="0" max="100" value="50" onchange="changeSFXVolume()">
                            <span id="sfxVolumeValue">50%</span>
                        </label>
                    </div>
                </div>
                
                <!-- Game Settings -->
                <div class="options-section">
                    <h3 class="options-section-title">üéÆ Game Settings</h3>
                    
                    <div class="setting-option">
                        <label class="setting-label">
                            <input type="checkbox" id="autoSaveCheckbox" onchange="toggleAutoSave()" checked>
                            Auto-save progress
                        </label>
                    </div>
                    
                    <div class="setting-option">
                        <label class="setting-label">
                            <input type="checkbox" id="animationsCheckbox" onchange="toggleAnimations()" checked>
                            Enable animations
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="options-footer">
                <button class="btn btn-secondary" onclick="resetOptions()">Reset to Defaults</button>
                <button class="btn" onclick="closeOptionsMenu()">Done</button>
            </div>
        </div>
    </div>

    <!-- Purchase Confirmation -->
    <div class="purchase-confirmation" id="purchaseConfirmation">
        <div class="confirmation-title">Confirm Purchase</div>
        <div class="confirmation-text" id="confirmationText"></div>
		<div class="confirmation-buttons">
			<button class="confirm-btn" onclick="(window.game || window.tempGameForMusic).confirmPurchase()">Purchase</button>
			<button class="cancel-btn" onclick="(window.game || window.tempGameForMusic).cancelPurchase()">Cancel</button>
		</div>
    </div>

    <!-- Gem Selection Modal -->
    <div class="gem-selection-modal" id="gemSelectionModal">
        <div class="gem-selection-title">Choose a Gem Type</div>
        <div class="gem-type-buttons" id="gemTypeButtons"></div>
    </div>

    <script>
		let _nextGemId = 1;

		// near the top of your script, before any usage:
		function formatNumber(n) {
		  return n.toLocaleString('en-US');
		}

        class Gemspire {
			constructor() {
				this.board = [];
				this.particleContainer = document.createElement('div');
				this.particleContainer.className = 'enhanced-particles';
				document.body.appendChild(this.particleContainer);
				this.selectedGem = null;
				this.score = 0;
				this.displayScore = 0;
				this.moves = 4;
				this.floor = 1;
				this.targetScore = 800;
				this.multiplier = 1.0;
				this.gemTypes = ['fire', 'ice', 'nature', 'lightning', 'void'];
				this.gemSymbols = {
					fire: 'üî•',
					ice: '‚ùÑÔ∏è',
					nature: 'üåø',
					lightning: '‚ö°',
					void: 'üåÄ'
				};
				this.animating = false;
				this.relics = [];
				this.cascadeCount = 0;
				this.matchCounter = 0;
				this.currentCombo = 0;
				this.isCurrentlyScoring = false;
				this._shuffleAnims = new Map();
				this._isShuffling = false;
				this.interactionsDisabled = false;
				this.originalTargetScore = null;

				this.consumableUsesThisFloor = 0;
				this.boosterUsesThisFloor = 0;
  
				this.scorePopupQueue = [];
				this.isProcessingPopups = false;
	
				// Basic relic effects
				this.bonusMoves = 0;
				this.baseMultiplier = 1;
				this.fireBoost = 1;
				this.lightningBoost = 1;
				this.voidBoost = 1;
				this.gemValueBoost = 1;
				this.comboBoost = 1;
				this.luckyCharm = false;
				this.diceOfFate = false;
				this.timeDilator = false;
				
				// Medium-level game changing relics
				this.explosiveMatches = false;
				this.gemAlchemy = false;
				this.cascadeMaster = false;
				this.voidHunger = false;
				this.stormSurge = false;

				this.jesterGambit = false;
				this.quantumMirror = false;
				this.entropyEngine = false;
				this.matchCountSinceJester = 0;
				this.cascadeCountTotal = 0;
				this.lastMatchPattern = null;
	
				// Crystal system - LOAD THESE FIRST
				this.crystals = this.loadCrystals();
				this.purchasedUpgrades = this.loadPurchasedUpgrades();
				this.consumableInventory = this.loadConsumableInventory();
				this.pendingPurchase = null;

				// Booster system
				this.activeBoosters = {};
				this.runBoosters = this.loadRunBoosters();

				// Cosmetic system
				this.activeTheme = this.loadActiveTheme();
				this.particleEffects = this.purchasedUpgrades['particle_effects'] || false;
				this.activeParticleEffects = this.particleEffects;
				
				// Consumable usage tracking
				this.pendingConsumable = null;
				
				// Game settings
				this.initializeGameSettings();
				
				// Initialize sound effects
				this.initializeSounds();
				this.createBackgroundAnimation();
				
				this.lightningStrikes = {}; // Track strikes per gem position
				
				this.initializeShop();
				
				// Apply Reality Breaker if purchased - NOW SAFE TO CHECK
				if (this.purchasedUpgrades['reality_breaker']) {
					this.multiplier = 3.0;
				}
			}

			async shuffleBoard() {
			  // make absolutely sure everything is back in the grid
			  document.querySelectorAll('.gem').forEach(el => {
				el.style.transform = '';
				el.style.transition = '';
			  });
			  this._shuffleAnims.forEach((anims, el) => {
				anims.forEach(a => a.cancel());
			  });
			  this._shuffleAnims.clear();
			  
			  if (this._isShuffling) return;
			  this._isShuffling = true;

			  // 0) Build the ID‚Üíposition map from the model:
			  const idToPos = new Map();
			  this.board.forEach((rowArr, r) =>
				rowArr.forEach((gem, c) => idToPos.set(gem.id, { oldRow: r, oldCol: c }))
			  );

			  // 1) Grab all .gem elems & clear any lingering transforms
			  const elems = Array.from(document.querySelectorAll('.gem'));
			  elems.forEach(el => {
				el.style.transform = '';
				el.style.transition = '';
				el.getBoundingClientRect();  // force reflow
			  });

			  // 2) Map IDs ‚Üí elements & cancel old animations
			  const idToEl = new Map();
			  elems.forEach(el => {
				idToEl.set(Number(el.dataset.gemId), el);
				const prev = this._shuffleAnims.get(el);
				if (prev) prev.forEach(a => a.cancel());
			  });
			  this._shuffleAnims.clear();

			  // 3) Flatten & shuffle the model
			  const flatArr = this.board.flat();
			  for (let i = flatArr.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[flatArr[i], flatArr[j]] = [flatArr[j], flatArr[i]];
			  }
			  // Build the new model matrix:
			  const newBoard = Array.from({length: 7}, () => Array(7));
			  flatArr.forEach((gem, idx) => {
				const r = Math.floor(idx / 7), c = idx % 7;
				newBoard[r][c] = gem;
			  });
			  // 4) Rebuild newBoard ‚Ä¶
			  for (let i = flatArr.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[flatArr[i], flatArr[j]] = [flatArr[j], flatArr[i]];
			  }

			  // 5) Animate each gem out & back in, *using idToPos for oldRow/oldCol*:
			  const tileSize = 54
			  const allSettles = flatArr.map((gem, newIdx) => {
				const el = idToEl.get(gem.id);
				if (!el) return Promise.resolve();

				// **grab the true old coords from the model map:**
				const { oldRow, oldCol } = idToPos.get(gem.id);
				const newRow = Math.floor(newIdx / 7), newCol = newIdx % 7;

				// ‚Ä¶ rest of your fling/juggle animation exactly as is ‚Ä¶
				const tossX = (Math.random()*2 -1) * tileSize * 2;
				const tossY = (Math.random()*2 -1) * tileSize * 2;
				const tossZ = 100 + Math.random()*200;
				const rotY  = (Math.random()*720 -360) + 'deg';

				const p1 = el.animate(
				  [ { transform: 'none' },
					{ transform: `
						perspective(800px)
						translate3d(${tossX}px, ${tossY}px, ${-tossZ}px)
						rotateY(${rotY})
						scale(1.2)
					  ` }
				  ],
				  { duration:400, easing:'ease-out', fill:'forwards' }
				);
				this._shuffleAnims.set(el, [p1]);

				return p1.finished.then(() => {
				  const finalX = (newCol - oldCol) * tileSize;
				  const finalY = (newRow - oldRow) * tileSize;
				  const p2 = el.animate(
					[ { transform: p1.effect.getComputedTiming().progress === 1
							  ? p1.effect.getKeyframes()[1].transform
							  : p1.effect.getKeyframes()[0].transform
					  },
					  { transform: `
						  translate3d(${finalX}px, ${finalY}px, 0)
						  scale(1)
						` }
					],
					{ duration:600, easing:'ease-in', fill:'forwards' }
				  );
				  this._shuffleAnims.get(el).push(p2);
				  return p2.finished.then(() => {
					el.style.gridRowStart    = newRow + 1;
					el.style.gridColumnStart = newCol + 1;
					// keep the DOM dataset in sync, too:
					el.dataset.row = newRow;
					el.dataset.col = newCol;
					el.getBoundingClientRect();
					requestAnimationFrame(() => el.style.transform = '');
				  });
				});
			  });

			  await Promise.allSettled(allSettles);
			  this.board = newBoard;
			  this.updateUI();
			   
   			  // CANCEL any lingering animations & clear transforms
			  this._shuffleAnims.forEach((anims, el) => {
			    anims.forEach(a => a.cancel());
			    el.style.transform  = '';
			    el.style.transition = '';
			  });

			for (let row = 0; row < 7; row++) {
			  for (let col = 0; col < 7; col++) {
				const gem = this.board[row][col];
				const el  = idToEl.get(String(gem.id));
				if (!el) continue;
				// make sure our dataset is correct
				el.dataset.row = row;
				el.dataset.col = col;
				// snap the CSS Grid into the right spot
				el.style.gridRowStart    = row + 1;
				el.style.gridColumnStart = col + 1;
				// clear any lingering transforms/transitions
				el.style.transform  = '';
				el.style.transition = '';
			  }
			}

			for (let row = 0; row < 7; row++) {
			  for (let col = 0; col < 7; col++) {
				const gem = this.board[row][col];
				const el  = idToEl.get(gem.id);   // <-- no String(‚Ä¶) wrapper
				if (!el) continue;
				el.dataset.row = row;
				el.dataset.col = col;
				el.style.gridRowStart    = row + 1;
				el.style.gridColumnStart = col + 1;
				el.style.transform  = '';
				el.style.transition = '';
			  }
			}
			this._shuffleAnims.clear();
			this._isShuffling = false;
			}
			
			animateShuffle() {
				document.querySelectorAll('.gem').forEach(el => {
					const dx = Math.random() * 400 - 200;
					const dy = Math.random() * 400 - 200;
					const rot = Math.random() * 720 - 360;
					el.style.setProperty('--dx', dx + 'px');
					el.style.setProperty('--dy', dy + 'px');
					el.style.setProperty('--rot', rot + 'deg');
					el.classList.add('shuffle-fly');
					el.addEventListener('animationend', () => {
						el.classList.remove('shuffle-fly');
						el.style.removeProperty('--dx');
						el.style.removeProperty('--dy');
						el.style.removeProperty('--rot');
					}, { once: true });
				});
			}

			disableAllInteractions() {
				console.log('Disabling all interactions');
				
				// Disable consumable buttons
				const consumableButtons = document.querySelectorAll('.consumable-btn');
				consumableButtons.forEach(btn => {
					btn.disabled = true;
					btn.style.opacity = '0.5';
					btn.style.cursor = 'not-allowed';
					btn.style.pointerEvents = 'none';
				});
				
				// Disable booster buttons
				const boosterButtons = document.querySelectorAll('.booster-btn');
				boosterButtons.forEach(btn => {
					btn.disabled = true;
					btn.style.opacity = '0.5';
					btn.style.cursor = 'not-allowed';
					btn.style.pointerEvents = 'none';
				});
				
				// Disable options button
				const optionsButton = document.querySelector('.options-btn');
				if (optionsButton) {
					optionsButton.disabled = true;
					optionsButton.style.opacity = '0.5';
					optionsButton.style.pointerEvents = 'none';
				}
				
				// Store that interactions are disabled (for gem click handler to check)
				this.interactionsDisabled = true;
			}

			enableAllInteractions() {
				console.log('Enabling all interactions');
				
				// Clear the disabled flag first
				this.interactionsDisabled = false;
				
				// Re-enable consumable buttons
				const consumableButtons = document.querySelectorAll('.consumable-btn');
				consumableButtons.forEach(btn => {
					btn.disabled = false;
					btn.style.opacity = '1';
					btn.style.cursor = 'pointer';
					btn.style.pointerEvents = 'auto';
				});
				
				// Re-enable booster buttons
				const boosterButtons = document.querySelectorAll('.booster-btn');
				boosterButtons.forEach(btn => {
					btn.disabled = false;
					btn.style.opacity = '1';
					btn.style.cursor = 'pointer';
					btn.style.pointerEvents = 'auto';
				});
				
				// Re-enable options button
				const optionsButton = document.querySelector('.options-btn');
				if (optionsButton) {
					optionsButton.disabled = false;
					optionsButton.style.opacity = '1';
					optionsButton.style.pointerEvents = 'auto';
				}
				
				// Force update displays now that interactions are enabled
				this.updateConsumablesDisplay();
				this.updateBoostersDisplay();
			}

            // Crystal and Shop System
            loadCrystals() {
                return parseInt(localStorage.getItem('gemspire_crystals') || '0');
            }

            saveCrystals() {
                localStorage.setItem('gemspire_crystals', this.crystals.toString());
            }

            loadPurchasedUpgrades() {
                const saved = localStorage.getItem('gemspire_purchased_upgrades');
                return saved ? JSON.parse(saved) : {};
            }

            savePurchasedUpgrades() {
                localStorage.setItem('gemspire_purchased_upgrades', JSON.stringify(this.purchasedUpgrades));
            }

            loadConsumableInventory() {
                const saved = localStorage.getItem('gemspire_consumables');
                return saved ? JSON.parse(saved) : {};
            }

            saveConsumableInventory() {
                localStorage.setItem('gemspire_consumables', JSON.stringify(this.consumableInventory));
            }

            loadRunBoosters() {
                const saved = sessionStorage.getItem('gemspire_run_boosters');
                return saved ? JSON.parse(saved) : {};
            }

            saveRunBoosters() {
                sessionStorage.setItem('gemspire_run_boosters', JSON.stringify(this.runBoosters));
            }

            loadActiveTheme() {
                return localStorage.getItem('gemspire_active_theme') || 'default';
            }

            saveActiveTheme() {
                localStorage.setItem('gemspire_active_theme', this.activeTheme);
            }

            loadGameSettings() {
                const saved = localStorage.getItem('gemspire_game_settings');
                return saved ? JSON.parse(saved) : {
                    autoSave: true,
                    animations: true,
                    musicVolume: 30,
                    sfxVolume: 50,
                    activeGemTheme: 'default',
                    activeBoardTheme: 'default',
                    activeParticleEffects: false
                };
            }

            saveGameSettings() {
                const settings = {
                    autoSave: this.autoSave,
                    animations: this.animations,
                    musicVolume: this.musicVolume,
                    sfxVolume: this.sfxVolume,
                    activeGemTheme: this.activeGemTheme,
                    activeBoardTheme: this.activeBoardTheme,
                    activeParticleEffects: this.activeParticleEffects
                };
                localStorage.setItem('gemspire_game_settings', JSON.stringify(settings));
            }

            initializeGameSettings() {
                const settings = this.loadGameSettings();
                this.autoSave = settings.autoSave;
                this.animations = settings.animations;
                this.musicVolume = settings.musicVolume;
                this.sfxVolume = settings.sfxVolume;
                this.activeGemTheme = settings.activeGemTheme;
                this.activeBoardTheme = settings.activeBoardTheme;
                this.activeParticleEffects = settings.activeParticleEffects;

				this.particleContainer = document.createElement('div');
				this.particleContainer.className = 'enhanced-particles';
				document.body.appendChild(this.particleContainer);

                // Apply volume settings
                this.updateVolumeSettings();
            }

			updateVolumeSettings() {
				if (this.sounds) {
					const musicVol = this.musicVolume / 100;
					const sfxVol = this.sfxVolume / 100;
					
					this.sounds.bg1.volume = this.audioEnabled ? musicVol : 0;
					this.sounds.title.volume = this.audioEnabled ? musicVol : 0;
					this.sounds.gameover.volume = this.audioEnabled ? musicVol : 0;
					
					this.sounds.swap.volume = sfxVol;
					this.sounds.clear.volume = sfxVol;
					this.sounds.place.volume = sfxVol * 0.8;
					this.sounds.relic.volume = sfxVol;
					this.sounds.purchase.volume = sfxVol;
					this.sounds.lose.volume = sfxVol;
					this.sounds.lightning.volume = sfxVol;
					this.sounds.void.volume = sfxVol;
					this.sounds.explode.volume = sfxVol;
					this.sounds.togglemute.volume = sfxVol;  // Add volume setting for the new sound
				}
			}		
			
			applyCurrentCosmetics() {
			  // 1) strip out any old theme classes
			  document.querySelectorAll('.gem.neon-theme').forEach(el => el.classList.remove('neon-theme'));
			  document.getElementById('gameBoard').classList.remove('space-theme');

			  // 2) apply the gem theme
			  if (this.activeGemTheme === 'neon' && this.purchasedUpgrades['gem_theme_neon']) {
				document.querySelectorAll('.gem').forEach(el => el.classList.add('neon-theme'));
			  }

			  // 3) apply the board theme
			  if (this.activeBoardTheme === 'space' && this.purchasedUpgrades['board_theme_space']) {
				document.getElementById('gameBoard').classList.add('space-theme');
			  }
			}

            updateOptionsMenu() {
                // Update cosmetic selects based on ownership
                const gemThemeSelect = document.getElementById('gemThemeSelect');
                const boardThemeSelect = document.getElementById('boardThemeSelect');
                const particleEffectsSelect = document.getElementById('particleEffectsSelect');
                const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
                const autoSaveCheckbox = document.getElementById('autoSaveCheckbox');
                const animationsCheckbox = document.getElementById('animationsCheckbox');
                
                if (gemThemeSelect) {
                    gemThemeSelect.value = this.activeGemTheme;
                    // Disable neon option if not owned
                    const neonOption = gemThemeSelect.querySelector('option[value="neon"]');
                    if (neonOption) {
                        if (!this.purchasedUpgrades['gem_theme_neon']) {
                            neonOption.disabled = true;
                            neonOption.textContent = 'Neon (Not Owned)';
                        } else {
                            neonOption.disabled = false;
                            neonOption.textContent = 'Neon (Premium)';
                        }
                    }
                }
                
                if (boardThemeSelect) {
                    boardThemeSelect.value = this.activeBoardTheme;
                    const spaceOption = boardThemeSelect.querySelector('option[value="space"]');
                    if (spaceOption) {
                        if (!this.purchasedUpgrades['board_theme_space']) {
                            spaceOption.disabled = true;
                            spaceOption.textContent = 'Space (Not Owned)';
                        } else {
                            spaceOption.disabled = false;
                            spaceOption.textContent = 'Space (Premium)';
                        }
                    }
                }
                
                if (particleEffectsSelect) {
                    particleEffectsSelect.value = this.activeParticleEffects.toString();
                    const enhancedOption = particleEffectsSelect.querySelector('option[value="true"]');
                    if (enhancedOption) {
                        if (!this.purchasedUpgrades['particle_effects']) {
                            enhancedOption.disabled = true;
                            enhancedOption.textContent = 'Enhanced (Not Owned)';
                        } else {
                            enhancedOption.disabled = false;
                            enhancedOption.textContent = 'Enhanced (Premium)';
                        }
                    }
                }
                
                if (musicVolumeSlider) {
                    musicVolumeSlider.value = this.musicVolume;
                    document.getElementById('musicVolumeValue').textContent = this.musicVolume + '%';
                }
                
                if (sfxVolumeSlider) {
                    sfxVolumeSlider.value = this.sfxVolume;
                    document.getElementById('sfxVolumeValue').textContent = this.sfxVolume + '%';
                }
                
                if (autoSaveCheckbox) {
                    autoSaveCheckbox.checked = this.autoSave;
                }
                
                if (animationsCheckbox) {
                    animationsCheckbox.checked = this.animations;
                }
				window.game.applyCurrentCosmetics();
            }

			destroyAllAudio() {
				if (this.sounds) {
					Object.values(this.sounds).forEach(sound => {
						sound.pause();
						sound.currentTime = 0;
						sound.volume = 0;
						sound.src = '';
						sound.load();
					});
					this.sounds = null;
				}
				this.currentBgMusic = null;
			}

			startGameTransition() {
				// Stop any currently playing background music
				this.stopBackgroundMusic();
				
				// Hide start screen and show game
				document.getElementById('startScreen').style.display = 'none';
				document.getElementById('gameContainer').style.display = 'flex';
				
				// Transfer audio settings from temp game instance
				if (window.tempGameForMusic) {
					window.tempGameForMusic.stopBackgroundMusic();
				}
				
				const audioEnabled = window.tempGameForMusic ? window.tempGameForMusic.audioEnabled : false;
				
				// Create new game instance
				game = new Gemspire();
				if (audioEnabled) {
					window.game.enableAudio();
				} else {
					window.game.disableAudio();
				}
				window.game.initializeGame();
			}

            grantStartingRelics() {
                const availableRelics = [
                    { name: 'üî• Fire Crown', desc: '+25% score from Fire gems', type: 'fire_boost', effect: () => { this.fireBoost = 1.25; } },
                    { name: '‚ùÑÔ∏è Ice Shard', desc: '+1 extra move per floor', type: 'extra_move', effect: () => { this.bonusMoves = (this.bonusMoves || 0) + 1; } },
                    { name: 'üåø Nature\'s Blessing', desc: '+25% base score multiplier', type: 'multiplier', effect: () => { this.baseMultiplier = (this.baseMultiplier || 1) + 0.25; } },
                    { name: '‚ö° Lightning Rod', desc: 'Lightning gems worth +25% more', type: 'lightning_boost', effect: () => { this.lightningBoost = 1.25; } },
                    { name: 'üåÄ Void Crystal', desc: 'Void gems worth +25% more', type: 'void_boost', effect: () => { this.voidBoost = 1.25; } },
                    { name: 'üíé Gem Forge', desc: 'All gems worth +25% more points', type: 'gem_value', effect: () => { this.gemValueBoost = (this.gemValueBoost || 1) + 0.25; } },
                    { name: 'üîó Chain Master', desc: 'Combo multiplier grows +25% faster', type: 'combo_boost', effect: () => { this.comboBoost = 1.25; } }
                ];
                
                // Grant 2 random relics
                for (let i = 0; i < 2; i++) {
                    if (availableRelics.length > 0) {
                        const randomIndex = Math.floor(Math.random() * availableRelics.length);
                        const selectedRelic = availableRelics.splice(randomIndex, 1)[0];
                        this.relics.push(selectedRelic);
                        selectedRelic.effect();
                    }
                }
            }

			applyGemTransmutation(row, col, newGemType) {
				// Close the gem selection modal
				this.closeGemSelectionModal();
				
				// Check if we have transmuter uses left
				if (!this.activeBoosters['gem_transmuter'] || this.activeBoosters['gem_transmuter'] <= 0) {
					return;
				}
				
				// Disable interactions during transmutation
				this.animating = true;
				this.disableAllInteractions();
				
				// Consume one use ONLY from active boosters
				this.activeBoosters['gem_transmuter']--;
				
				// If no more uses left, remove from active boosters
				if (this.activeBoosters['gem_transmuter'] <= 0) {
					delete this.activeBoosters['gem_transmuter'];
				}
				
				// Create the new gem
				const newGem = {
					type: newGemType,
					symbol: this.gemSymbols[newGemType],
					value: Math.floor(Math.random() * 25) + 40,
					isThunderbolt: false,
					strikeCount: 0
				};
				
				// Apply gem value boost if applicable
				newGem.value = Math.floor(newGem.value * this.gemValueBoost);
				
				// Replace the gem on the board
				this.board[row][col] = newGem;
				
				// Update the visual element
				const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
				if (elem) {
					this.updateGemElement(elem, newGem);
					
					// Add a special effect to show the transmutation
					elem.style.transform = 'scale(1.3)';
					elem.style.transition = 'transform 0.3s ease';
					
					setTimeout(() => {
						elem.style.transform = 'scale(1)';
					}, 300);
				}
				
				// Show feedback with remaining uses
				const remainingUses = this.activeBoosters['gem_transmuter'] || 0;
				if (remainingUses > 0) {
					this.showComboIndicator(`üîÑ GEM TRANSMUTED! (${remainingUses} uses left)`);
				} else {
					this.showComboIndicator('üîÑ GEM TRANSMUTED!');
				}
				
				// Update the boosters display
				this.updateBoostersDisplay();
				
				// Play a sound effect
				this.playSound('relic');
				
				// Wait for animation, then check for matches and re-enable
				setTimeout(async () => {
					// Process any matches that resulted from the transmutation
					await this.processMatches();
					
					// Update UI and check game state
					this.updateUI();
					this.checkGameState();
					
					// Re-enable interactions
					this.animating = false;
					this.enableAllInteractions();
				}, 400);
			}

            showCrystalGain(amount) {
                const crystalDisplay = document.getElementById('crystalAmount');
                if (!crystalDisplay) return;

                const crystalGain = document.createElement('div');
                crystalGain.className = 'crystal-gain';
                crystalGain.textContent = `+${amount} üíé`;
                
                const rect = crystalDisplay.getBoundingClientRect();
                crystalGain.style.left = rect.left + 'px';
                crystalGain.style.top = rect.top + 'px';
                
                document.body.appendChild(crystalGain);
                
                crystalGain.offsetHeight;
                crystalGain.classList.add('animate');
                
                setTimeout(() => {
                    if (crystalGain.parentNode) {
                        crystalGain.parentNode.removeChild(crystalGain);
                    }
                }, 2000);
            }

			initializeShop() {
				this.shopItems = {
					permanent: [
						{
							id: 'gem_mastery',
							name: 'üíé Gem Mastery',
							desc: 'All gems start with +10 base value each run',
							price: 15000,
							rarity: 'common',
							type: 'Permanent Upgrade'
						},
						{
							id: 'move_master',
							name: 'üéØ Move Master',
							desc: 'Start each run with +1 extra move per floor',
							price: 25000,
							rarity: 'rare',
							type: 'Permanent Upgrade'
						},
						{
							id: 'relic_insight',
							name: 'üîÆ Relic Insight',
							desc: 'See 4 relic choices instead of 3',
							price: 20000,
							rarity: 'common',
							type: 'Permanent Upgrade'
						},
						{
							id: 'score_prophet',
							name: 'üìä Score Prophet',
							desc: 'See target scores for the next 3 floors',
							price: 12000,
							rarity: 'common',
							type: 'Permanent Upgrade'
						},
						{
							id: 'crystal_resonance',
							name: 'üíé Crystal Resonance',
							desc: 'Gain +100% more crystals from all sources',
							price: 40000,
							rarity: 'epic',
							type: 'Permanent Upgrade'
						}
					],
					boosters: [
						{
							id: 'lucky_streak',
							name: 'üçÄ Lucky Streak',
							desc: 'Next 3 matches have 50% chance to not consume a move',
							price: 4500,
							rarity: 'rare',
							type: 'Run Booster'
						},
						{
							id: 'gem_transmuter',
							name: 'üîÑ Gem Transmuter',
							desc: 'Convert any gem type to another (1 uses per booster)',
							price: 3800,
							rarity: 'common',
							type: 'Run Booster'
						},
						{
							id: 'score_shield',
							name: 'üõ°Ô∏è Score Shield',
							desc: 'Reduce target score by 50% for current floor',
							price: 6000,
							rarity: 'rare',
							type: 'Run Booster'
						},
						{
							id: 'cascade_catalyst',
							name: 'üåä Cascade Catalyst',
							desc: 'Next match triggers guaranteed cascade',
							price: 4200,
							rarity: 'common',
							type: 'Run Booster'
						}
					],
					consumables: [
						{
							id: 'lightning_storm',
							name: '‚ö° Lightning Storm',
							desc: 'Strike all gems of chosen type for massive score',
							price: 5500,
							rarity: 'rare',
							type: 'Consumable',
							stackable: true
						},
						{
							id: 'void_collapse',
							name: 'üï≥Ô∏è Void Collapse',
							desc: 'Remove all gems of lowest value',
							price: 3500,
							rarity: 'common',
							type: 'Consumable',
							stackable: true
						},
						{
							id: 'gem_forge',
							name: 'üî® Gem Forge',
							desc: 'Upgrade 5 random gems to maximum value',
							price: 6500,
							rarity: 'rare',
							type: 'Consumable',
							stackable: true
						},
						{
							id: 'time_freeze',
							name: '‚è∞ Time Freeze',
							desc: 'Pause move counter for 1 move',
							price: 10000,
							rarity: 'common',
							type: 'Consumable',
							stackable: true
						}
					],
					prestige: [
						{
							id: 'ascended_mastery',
							name: 'üåü Ascended Gem Mastery',
							desc: 'All gems start at 50+ value',
							price: 100000,
							rarity: 'legendary',
							type: 'Prestige Upgrade'
						},
						{
							id: 'arcane_amplifier',
							name: 'üí† Arcane Amplifier',
							desc: 'Increase crystal gain by 500%',
							price: 150000,
							rarity: 'legendary',
							type: 'Prestige Upgrade'
						},
						{
							id: 'score_overflow',
							name: '‚ôæÔ∏è Score Overflow',
							desc: 'Carry 1% of excess score to next floor',
							price: 500000,
							rarity: 'legendary',
							type: 'Prestige Upgrade'
						},
						{
							id: 'relic_abundance',
							name: 'üîÆ Relic Abundance',
							desc: 'Start each run with 2 random relics already equipped',
							price: 300000,
							rarity: 'legendary',
							type: 'Prestige Upgrade'
						},
						{
							id: 'reality_breaker',
							name: 'üåå Reality Breaker',
							desc: 'Score multiplier starts at 3x',
							price: 2000000,
							rarity: 'legendary',
							type: 'Prestige Upgrade'
						}
					],
					cosmetics: [
						{
							id: 'gem_theme_neon',
							name: 'üåà Neon Gem Theme',
							desc: 'Bright neon colors for all gems',
							price: 8000,
							rarity: 'common',
							type: 'Cosmetic'
						},
						{
							id: 'particle_effects',
							name: '‚ú® Enhanced Particles',
							desc: 'Beautiful particle effects for matches',
							price: 15000,
							rarity: 'rare',
							type: 'Cosmetic'
						},
						{
							id: 'board_theme_space',
							name: 'üåå Space Board Theme',
							desc: 'Transform the board into a cosmic battlefield',
							price: 25000,
							rarity: 'epic',
							type: 'Cosmetic'
						}
					]
				};
			}  
			
			initializeSounds() {
				// Destroy any existing sounds first
				this.destroyAllAudio();
				
				this.sounds = {
					swap: new Audio('swap.mp3'),
					clear: new Audio('clear.mp3'),
					lightning: new Audio('lightning.mp3'),
					void: new Audio('void.mp3'),
					explode: new Audio('explode.mp3'),
					place: new Audio('place.mp3'),
					relic: new Audio('relic.mp3'),
					purchase: new Audio('purchase.mp3'),
					bg1: new Audio('bg1.mp3'),
					title: new Audio('title.mp3'),
					lose: new Audio('lose.mp3'),
					gameover: new Audio('gameover.mp3'),
					togglemute: new Audio('togglemute.mp3')  // Add the new sound
				};
				
				// Set volume levels
				this.sounds.swap.volume = 0.5;
				this.sounds.clear.volume = 0.6;
				this.sounds.place.volume = 0.4;
				this.sounds.relic.volume = 0.7;
				this.sounds.purchase.volume = 0.6;
				this.sounds.lose.volume = 0.8;
				this.sounds.togglemute.volume = 0.7;  // Set volume for the new sound				
				// Background music settings - START MUTED AND PAUSED
				this.sounds.bg1.volume = 0;
				this.sounds.bg1.loop = true;
				this.sounds.title.volume = 0;
				this.sounds.title.loop = true;
				this.sounds.gameover.volume = 0;
				this.sounds.gameover.loop = true;
				
				// Audio control state
				this.audioEnabled = false;
				this.bgMusicVolume = 0.3;
				this.titleMusicVolume = 0.4;
				this.audioPermissionGiven = false;
				
				// Preload sounds
				Object.values(this.sounds).forEach(sound => {
					sound.preload = 'auto';
					sound.addEventListener('error', () => {
						console.log(`Sound file not found: ${sound.src}`);
					});
				});
				
				this.currentBgMusic = null;
			}
            
			enableAudio() {
				this.audioEnabled = true;
				this.audioPermissionGiven = true;
				
				// Update all volume settings
				this.updateVolumeSettings();
				
				// If we have a current background music track, make sure it's playing
				if (this.currentBgMusic && this.sounds[this.currentBgMusic]) {
					this.sounds[this.currentBgMusic].volume = this.musicVolume / 100;
					this.sounds[this.currentBgMusic].play().catch(e => {
						console.log('Background music play failed:', e);
					});
				}
				
				this.updateIngameAudioToggle();
			}
            
			disableAudio() {
				this.audioEnabled = false;
				this.audioPermissionGiven = true;
				
				// Pause all currently playing music
				if (this.currentBgMusic && this.sounds[this.currentBgMusic]) {
					this.sounds[this.currentBgMusic].pause();
				}
				
				this.updateVolumeSettings();
				this.updateIngameAudioToggle();
			}
            
			toggleIngameAudio() {
				console.log('toggleIngameAudio called, current audioEnabled:', this.audioEnabled);
				
				if (!this.audioPermissionGiven) return;
				
				// Always play the toggle sound, regardless of current state
				// We need to handle this specially since we can't use this.playSound() when audio is disabled
				const toggleSound = this.sounds.togglemute;
				if (toggleSound) {
					toggleSound.currentTime = 0;
					toggleSound.volume = this.sfxVolume / 100;  // Use SFX volume
					toggleSound.play().catch(e => {
						console.log('Toggle sound play failed:', e);
					});
				}
				
				if (this.audioEnabled) {
					console.log('Disabling audio...');
					this.disableAudio();
				} else {
					console.log('Enabling audio...');
					this.enableAudio();
					
					// Start appropriate background music
					const startScreen = document.getElementById('startScreen');
					const gameContainer = document.getElementById('gameContainer');
					
					if (startScreen && startScreen.style.display !== 'none') {
						this.playBackgroundMusic('title');
					} else if (gameContainer && gameContainer.style.display !== 'none') {
						this.playBackgroundMusic('bg1');
					}
				}
				
				console.log('After toggle, audioEnabled:', this.audioEnabled);
			}
			
			updateIngameAudioToggle() {
				const toggle = document.getElementById('ingameAudioToggle');
				if (!toggle) return;
				
				if (this.audioEnabled) {
					toggle.textContent = 'üîä';
					toggle.classList.add('audio-enabled');
				} else {
					toggle.textContent = 'üîá';
					toggle.classList.remove('audio-enabled');
				}
			}
            
            showIngameAudioToggle() {
                const toggle = document.getElementById('ingameAudioToggle');
                if (toggle && this.audioPermissionGiven) {
                    toggle.style.display = 'flex';
                    this.updateIngameAudioToggle();
                }
            }
            
            hideIngameAudioToggle() {
                const toggle = document.getElementById('ingameAudioToggle');
                if (toggle) {
                    toggle.style.display = 'none';
                }
            }
            
            playSound(soundName) {
                try {
                    if (this.sounds[soundName] && this.audioEnabled) {
                        this.sounds[soundName].currentTime = 0;
                        this.sounds[soundName].play().catch(e => {
                            console.log('Audio play failed:', e);
                        });
                    }
                } catch (error) {
                    console.log('Sound playback error:', error);
                }
            }
            
			playBackgroundMusic(musicName) {
				try {
					// Stop current background music
					if (this.currentBgMusic && this.currentBgMusic !== musicName) {
						this.sounds[this.currentBgMusic].pause();
						this.sounds[this.currentBgMusic].currentTime = 0;
					}
					
					// Always set the current music track
					this.currentBgMusic = musicName;
					
					// Reset the track to beginning
					if (this.sounds[musicName]) {
						this.sounds[musicName].currentTime = 0;
						
						// Only play if audio is enabled
						if (this.audioEnabled) {
							// Make sure volume is set correctly before playing
							this.sounds[musicName].volume = this.musicVolume / 100;
							
							// Force play regardless of previous state
							this.sounds[musicName].play().catch(e => {
								console.log('Background music play failed:', e);
							});
						}
					}
				} catch (error) {
					console.log('Background music error:', error);
				}
			}
            
			stopBackgroundMusic() {
				console.log('Stopping background music, current:', this.currentBgMusic);
				if (this.currentBgMusic && this.sounds && this.sounds[this.currentBgMusic]) {
					this.sounds[this.currentBgMusic].pause();
					this.sounds[this.currentBgMusic].currentTime = 0;
					this.sounds[this.currentBgMusic].volume = 0;
				}
				this.currentBgMusic = null;
			}
            
            stopBackgroundMusic() {
                if (this.currentBgMusic) {
                    this.sounds[this.currentBgMusic].pause();
                    this.sounds[this.currentBgMusic].currentTime = 0;
                    this.currentBgMusic = null;
                }
            }
            
            createBackgroundAnimation() {
                const bgAnimation = document.getElementById('bgAnimation');
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'bg-particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 6 + 's';
                    particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                    bgAnimation.appendChild(particle);
                }
            }
            
            updateCrystalDisplay() {
                document.getElementById('crystalAmount').textContent = formatNumber(this.crystals);
                const shopAmount = document.getElementById('shopCrystalAmount');
                if (shopAmount) {
                    shopAmount.textContent = formatNumber(this.crystals);
                }
            }

			calculateCrystalGain(finalScore, targetScore) {
				if (finalScore <= targetScore) return 0;
				
				const overage = finalScore - targetScore;
				const overageMultiplier = finalScore / targetScore;
				
				let crystalGain = Math.floor(overage / 1000);
				
				// Bonus multipliers for extreme overages
				if (overageMultiplier >= 100) {
					crystalGain = Math.floor(crystalGain * 3); // +200% bonus
				} else if (overageMultiplier >= 50) {
					crystalGain = Math.floor(crystalGain * 2); // +100% bonus
				} else if (overageMultiplier >= 10) {
					crystalGain = Math.floor(crystalGain * 1.5); // +50% bonus
				}
				
				// Apply crystal multiplier upgrades
				let multiplier = 1;
				
				// Apply crystal resonance upgrade if owned (doubles crystal gain)
				if (this.purchasedUpgrades['crystal_resonance']) {
					multiplier *= 2;
				}
				
				// Apply arcane amplifier upgrade if owned (6x crystal gain - 500% increase + base 100%)
				if (this.purchasedUpgrades['arcane_amplifier']) {
					multiplier *= 6;
				}
				
				// Apply the combined multiplier
				crystalGain = Math.floor(crystalGain * multiplier);
				
				return crystalGain;
			}

            awardCrystals(amount) {
                if (amount <= 0) return;
                
                this.crystals += amount;
                this.saveCrystals();
                this.updateCrystalDisplay();
                
                // Show crystal gain animation
                this.showCrystalGain(amount);
            }

            renderShopItems() {
                Object.keys(this.shopItems).forEach(category => {
                    const container = document.getElementById(category + 'Items');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    
                    this.shopItems[category].forEach(item => {
                        const itemElement = this.createShopItemElement(item);
                        container.appendChild(itemElement);
                    });
                });
            }

            createShopItemElement(item) {
                const div = document.createElement('div');
                div.className = `shop-item ${item.rarity}`;
                
                const isOwned = this.purchasedUpgrades[item.id];
                const quantity = this.consumableInventory[item.id] || 0;
                
                if (isOwned && !item.stackable) {
                    div.classList.add('owned');
                }
                
                const canAfford = this.crystals >= item.price;
                const canPurchase = canAfford && (!isOwned || item.stackable);
                
                div.innerHTML = `
                    <div class="shop-item-header">
                        <div>
                            <div class="shop-item-name">${item.name}</div>
                            <div class="shop-item-type">${item.type}</div>
                        </div>
                        <div class="shop-item-price">
                            <span class="crystal-icon">üíé</span>
                            <span>${formatNumber(item.price)}</span>
                        </div>
                    </div>
                    <div class="shop-item-desc">${item.desc}</div>
                    <div class="shop-item-footer">
                        ${item.stackable ? `<div class="shop-item-quantity">Owned: ${formatNumber(quantity)}</div>` : '<div></div>'}
						<button class="shop-buy-btn" ${!canPurchase ? 'disabled' : ''} 
								onclick="(window.game || window.tempGameForMusic).initiatePurchase('${item.id}')">
							${isOwned && !item.stackable ? 'OWNED' : 'BUY'}
						</button>
                    </div>
                `;
                
                return div;
            }

            openShop() {
                this.updateCrystalDisplay();
                this.renderShopItems();
                document.getElementById('shopScreen').style.display = 'block';
            }

			closeShop() {
				console.log('closeShop method called');
				document.getElementById('shopScreen').style.display = 'none';
				
				// Only continue to relic selection if we're actually in a game
				const gameContainer = document.getElementById('gameContainer');
				if (gameContainer && gameContainer.style.display !== 'none') {
					console.log('In game, continuing to relic selection');
					setTimeout(() => {
						this.actuallyShowRelicSelection();
					}, 100);
				} else {
					console.log('Not in game, shop closed without relic selection');
				}
			}
			
            actuallyShowRelicSelection() {
				this.disableAllInteractions();
                const relicScreen = document.getElementById('relicSelectionScreen');
                const relicOptions = document.getElementById('relicOptions');
                
                const availableRelics = [
                    { name: 'üî• Fire Crown', desc: '+25% score from Fire gems', type: 'fire_boost', effect: () => { this.fireBoost = 1.25; } },
                    { name: '‚ùÑÔ∏è Ice Shard', desc: '+1 extra move per floor', type: 'extra_move', effect: () => { this.bonusMoves = (this.bonusMoves || 0) + 1; } },
                    { name: 'üåø Nature\'s Blessing', desc: '+25% base score multiplier', type: 'multiplier', effect: () => { this.baseMultiplier = (this.baseMultiplier || 1) + 0.25; } },
                    { name: '‚ö° Lightning Rod', desc: 'Lightning gems worth +25% more', type: 'lightning_boost', effect: () => { this.lightningBoost = 1.25; } },
                    { name: 'üåÄ Void Crystal', desc: 'Void gems worth +25% more', type: 'void_boost', effect: () => { this.voidBoost = 1.25; } },
                    { name: 'üíé Gem Forge', desc: 'All gems worth +25% more points', type: 'gem_value', effect: () => { this.gemValueBoost = (this.gemValueBoost || 1) + 0.25; } },
                    { name: 'üîó Chain Master', desc: 'Combo multiplier grows +25% faster', type: 'combo_boost', effect: () => { this.comboBoost = 1.25; } },
                    { name: 'üìâ Score Amplifier', desc: 'Target score reduced by 25%', type: 'score_reduction', effect: () => { this.targetScore = Math.floor(this.targetScore * 0.75); } },
                    { name: 'üçÄ Lucky Charm', desc: 'Higher value gems appear more often', type: 'lucky', effect: () => { this.luckyCharm = true; } },
                    { name: 'üîÆ Mana Crystal', desc: '+2 extra moves per floor', type: 'mega_moves', effect: () => { this.bonusMoves = (this.bonusMoves || 0) + 2; } },
                    { name: 'üé≤ Dice of Fate', desc: '15% chance moves don\'t consume', type: 'lucky_moves', effect: () => { this.diceOfFate = true; } },
                    { name: '‚è∞ Time Dilator', desc: 'Target score decreases by 25 each move', type: 'time_decay', effect: () => { this.timeDilator = true; } },
                    { name: 'üí• Explosive Matches', desc: '4+ matches of same gem type explode all adjacent gems for 50% score', type: 'explosive_matches', effect: () => { this.explosiveMatches = true; } },
                    { name: 'üß™ Gem Alchemy', desc: 'Every 3rd match converts all gems of that type to highest value', type: 'gem_alchemy', effect: () => { this.gemAlchemy = true; } },
                    { name: 'üåä Cascade Master', desc: 'Every 2nd cascade permanently increases base multiplier', type: 'cascade_master', effect: () => { this.cascadeMaster = true; } },
                    { name: 'üï≥Ô∏è Void Hunger', desc: 'Void matches consume and score from surrounding gems', type: 'void_hunger', effect: () => { this.voidHunger = true; } },
                    { name: '‚ö° Storm Surge', desc: 'Lightning matches strike all Lightning gems on board, scoring them and increasing their value by +5', type: 'storm_surge', effect: () => { this.stormSurge = true; } }
                ];

				const gameChangingRelics = [
					{
						name: 'üé≠ Jester\'s Gambit',
						desc: 'Every 4 matches cascades all rows involved in those matches',
						type: 'jester_gambit',
						effect: () => { this.jesterGambit = true; }
					},
					{
						name: 'üîÆ Quantum Mirror',
						desc: 'Reflects the last match, duplicating its score & pattern',
						type: 'quantum_mirror',
						effect: () => { this.quantumMirror = true; }
					},
					{
						name: '‚öôÔ∏è Entropy Engine',
						desc: 'Randomly shuffles board every 5 cascades',
						type: 'entropy_engine',
						effect: () => { this.entropyEngine = true; }
					}
				];
				// merge into existing array
				availableRelics.push(...gameChangingRelics);
	
                const newRelics = availableRelics.filter(relic => 
                    !this.relics.some(owned => owned.type === relic.type)
                );
                
                const selectedRelics = [];
                
                if (newRelics.length === 0) {
                    selectedRelics.push({
                        name: 'üöÄ Continue Journey',
                        desc: 'Continue to the next floor with current relics',
                        type: 'continue',
                        effect: () => {}
                    });
                } else {
                    const relicCount = this.purchasedUpgrades['relic_insight'] ? 4 : 3;
                    for (let i = 0; i < relicCount && newRelics.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * newRelics.length);
                        selectedRelics.push(newRelics.splice(randomIndex, 1)[0]);
                    }
                }
                
                relicOptions.innerHTML = '';
                selectedRelics.forEach((relic) => {
                    const relicButton = document.createElement('button');
                    relicButton.className = relic.type === 'continue' ? 'relic-option continue-option' : 'relic-option';
                    relicButton.innerHTML = `
                        <div class="relic-option-name">${relic.name}</div>
                        <div class="relic-option-desc">${relic.desc}</div>
                    `;
                    relicButton.onclick = () => this.selectRelic(relic);
                    relicOptions.appendChild(relicButton);
                });
                
                relicScreen.style.display = 'block';
            }

            switchShopTab(category) {
                // Update tab buttons
                document.querySelectorAll('.shop-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Find the clicked tab and make it active
                const clickedTab = Array.from(document.querySelectorAll('.shop-tab')).find(tab => 
                    tab.textContent.includes(category.charAt(0).toUpperCase() + category.slice(1)) ||
                    (category === 'permanent' && tab.textContent.includes('Permanent')) ||
                    (category === 'boosters' && tab.textContent.includes('Boosters')) ||
                    (category === 'consumables' && tab.textContent.includes('Consumables')) ||
                    (category === 'prestige' && tab.textContent.includes('Prestige')) ||
                    (category === 'cosmetics' && tab.textContent.includes('Cosmetics'))
                );
                if (clickedTab) {
                    clickedTab.classList.add('active');
                }
                
                // Update content
                document.querySelectorAll('.shop-category').forEach(cat => {
                    cat.classList.remove('active');
                });
                document.getElementById(category).classList.add('active');
            }

			applyPermanentUpgrades() {
				if (this.purchasedUpgrades['gem_mastery']) {
					this.gemValueBoost += 0.1;
				}
				if (this.purchasedUpgrades['move_master']) {
					this.bonusMoves = 1;
				}
				if (this.purchasedUpgrades['relic_abundance']) {
					this.grantStartingRelics();
				}
			}

            initiatePurchase(itemId) {
                const item = Object.values(this.shopItems).flat().find(i => i.id === itemId);
                if (!item) return;
                
                this.pendingPurchase = item;
                
                const confirmationText = document.getElementById('confirmationText');
                confirmationText.innerHTML = `Are you sure you want to purchase <strong>${item.name}</strong> for <span style="color: #8b5cf6;">üíé ${item.price}</span>?`;
                
                document.getElementById('purchaseConfirmation').style.display = 'block';
            }

            confirmPurchase() {
                const item = this.pendingPurchase;
                if (!item) return;
                
                if (this.crystals >= item.price) {
                    // Play purchase sound
                    this.playSound('purchase');
                    
                    this.crystals -= item.price;
                    this.saveCrystals();
                    this.updateCrystalDisplay();
                    
                    if (item.type === 'Permanent Upgrade' || item.type === 'Prestige Upgrade' || item.type === 'Cosmetic') {
                        this.purchasedUpgrades[item.id] = true;
                        this.savePurchasedUpgrades();
                        this.applyPermanentUpgrades();
                    } else if (item.type === 'Consumable') {
                        if (!this.consumableInventory[item.id]) {
                            this.consumableInventory[item.id] = 0;
                        }
                        this.consumableInventory[item.id]++;
                        this.saveConsumableInventory();
                        this.updateConsumablesDisplay();
                    } else if (item.type === 'Run Booster') {
                        if (!this.runBoosters[item.id]) {
                            this.runBoosters[item.id] = 0;
                        }
                        this.runBoosters[item.id]++;
                        this.saveRunBoosters();
                        this.updateBoostersDisplay();
                    }
                    
                    this.renderShopItems();
                }
                
                this.closePurchaseConfirmation();
            }

            closePurchaseConfirmation() {
                document.getElementById('purchaseConfirmation').style.display = 'none';
                this.pendingPurchase = null;
            }

            cancelPurchase() {
                this.closePurchaseConfirmation();
            }

			updateConsumablesDisplay() {
				// Don't update during animations to prevent re-enabling buttons
				if (this.interactionsDisabled || this.animating) {
					return;
				}
				
				const panel = document.getElementById('consumablesPanel');
				const buttonsContainer = document.getElementById('consumableButtons');
				
				if (!panel || !buttonsContainer) return;
				
				buttonsContainer.innerHTML = '';
				
				let hasConsumables = false;
				for (const itemId in this.consumableInventory) {
					if (this.consumableInventory[itemId] > 0) {
						hasConsumables = true;
						break;
					}
				}
				
				if (hasConsumables) {
					panel.style.display = 'block';

					// update header to show how many of 2 used
					const hdr = panel.querySelector('h4');
					if (hdr) hdr.textContent = `üí´ Consumables (${this.consumableUsesThisFloor}/2)`;

					for (const itemId in this.consumableInventory) {
						if (this.consumableInventory[itemId] > 0) {
							const item = this.shopItems.consumables.find(c => c.id === itemId);
							if (item) {
								const button = document.createElement('button');
								button.className = 'consumable-btn';
								button.textContent = item.name;
								button.dataset.itemId = itemId;
								button.onclick = () => this.useConsumable(itemId);
								
								// Apply disabled state if interactions are disabled
								if (this.interactionsDisabled || this.animating) {
									button.disabled = true;
									button.style.opacity = '0.5';
									button.style.cursor = 'not-allowed';
									button.style.pointerEvents = 'none';
								}
								
								const countSpan = document.createElement('span');
								countSpan.className = 'consumable-count';
								countSpan.textContent = this.consumableInventory[itemId];
								button.appendChild(countSpan);
								
								buttonsContainer.appendChild(button);
							}
						}
					}
				} else {
					panel.style.display = 'none';
				}
			}

			useConsumable(itemId) {
				console.log('useConsumable called with:', itemId);
				
				if (!this.consumableInventory[itemId] || this.consumableInventory[itemId] <= 0) {
					console.log('No consumable available');
					return;
				}
				
				const item = this.shopItems.consumables.find(c => c.id === itemId);
				if (!item) {
					console.log('Item not found');
					return;
				}
				
				if (itemId === 'lightning_storm') {
					console.log('Showing lightning storm modal');
					// Don't set pendingConsumable, just show the modal
					this.showGemSelectionModal();
				} else {
					// For other consumables, set pendingConsumable as before
					this.pendingConsumable = item;
					
					if (itemId === 'void_collapse') {
						this.applyVoidCollapse();
					} else if (itemId === 'gem_forge') {
						this.applyGemForge();
					} else if (itemId === 'time_freeze') {
						this.applyTimeFreeze();
					}
				}

				// track and charge move every 2 uses this floor
				this.consumableUsesThisFloor++;
				if (this.consumableUsesThisFloor >= 2) {
				  this.consumableUsesThisFloor -= 2;
				  this.moves--;
				  this.showComboIndicator('üí´ 2 consumables used ‚Üí ‚Äì1 Move');
				  this.updateUI();
				}
			}

			showGemSelectionModal() {
				console.log('showGemSelectionModal called for lightning storm');
				
				const modal = document.getElementById('gemSelectionModal');
				const title = modal.querySelector('.gem-selection-title');
				const buttonsContainer = modal.querySelector('.gem-type-buttons');
				
				title.textContent = 'Choose a Gem Type to Strike';
				buttonsContainer.innerHTML = '';
				
				// Store the consumable info on the modal itself
				modal.dataset.consumableId = 'lightning_storm';
				
				this.gemTypes.forEach(type => {
					const button = document.createElement('button');
					button.className = `gem-type-btn ${type}`;
					button.textContent = this.gemSymbols[type];
					button.style.cursor = 'pointer';
					button.dataset.gemType = type;
					
					// Use direct method call without relying on pendingConsumable
					button.onclick = () => {
						console.log('Lightning storm button clicked for type:', type);
						this.closeGemSelectionModal();
						this.applyLightningStormDirect(type);
					};
					
					buttonsContainer.appendChild(button);
					console.log('Added lightning button for', type);
				});
				
				modal.style.display = 'block';
				console.log('Lightning storm modal shown');
			}

            showGemTransmuterModal(row, col) {
                const modal = document.getElementById('gemSelectionModal');
                const title = modal.querySelector('.gem-selection-title');
                const buttonsContainer = modal.querySelector('.gem-type-buttons');
                
                title.textContent = 'Choose New Gem Type';
                buttonsContainer.innerHTML = '';
                
                this.gemTypes.forEach(type => {
                    const button = document.createElement('button');
                    button.className = `gem-type-btn ${type}`;
                    button.textContent = this.gemSymbols[type];
                    button.dataset.gemType = type;
                    button.onclick = () => this.applyGemTransmutation(row, col, type);
                    buttonsContainer.appendChild(button);
                });
                
                modal.style.display = 'block';
            }

			closeGemSelectionModal() {
				const modal = document.getElementById('gemSelectionModal');
				if (modal) {
					modal.style.display = 'none';
				}
				
				// Clear any pending consumable if modal is closed without selection
				this.pendingConsumable = null;
			}

			async applyLightningStormDirect(gemType) {
				console.log('=== APPLY LIGHTNING STORM DIRECT START ===');
				console.log('gemType:', gemType);
				
				// Check if we have lightning storm consumables
				if (!this.consumableInventory['lightning_storm'] || this.consumableInventory['lightning_storm'] <= 0) {
					console.error('No lightning storm consumables available!');
					this.showComboIndicator('‚ö° No Lightning Storms available!');
					return;
				}
				
				// Disable interactions during lightning storm
				this.animating = true;
				
				console.log('Consuming lightning storm directly...');
				
				// Consume the lightning storm from inventory
				this.consumableInventory['lightning_storm']--;
				this.saveConsumableInventory();
				this.updateConsumablesDisplay();
				
				let totalStormScore = 0;
				const struckGems = [];
				
				console.log('Searching for gems of type:', gemType);
				
				// Find all gems of the selected type and mark them for removal
				for (let row = 0; row < 7; row++) {
					for (let col = 0; col < 7; col++) {
						const gem = this.board[row][col];
						if (gem && gem.type === gemType) {
							console.log(`Found ${gemType} gem at ${row},${col} with value ${gem.value}`);
							
							// Score the gem
							totalStormScore += gem.value * 2;
							struckGems.push({row, col});
							
							// Add visual strike effect
							const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
							if (elem) {
								elem.classList.add('lightning-strike');
							}
						}
					}
				}
				
				console.log('Total gems struck:', struckGems.length);
				console.log('Total storm score before multipliers:', totalStormScore);
				
				if (struckGems.length === 0) {
					this.showComboIndicator(`‚ö° No ${this.gemSymbols[gemType]} gems found!`);
					this.animating = false; // Re-enable interactions
					return;
				}
				
				// Add storm score
				const finalStormScore = Math.floor(totalStormScore * this.multiplier * this.baseMultiplier);
				this.score += finalStormScore;
				this.animateScoreIncrease(finalStormScore);
				
				this.showComboIndicator(`‚ö° LIGHTNING STORM! +${finalStormScore} points!`);
				this.playSound('lightning');
				
				console.log('Final storm score:', finalStormScore);
				
				// Wait for visual effect
				await new Promise(resolve => setTimeout(resolve, 300));
				
				// Remove all struck gems from the board
				for (const {row, col} of struckGems) {
					this.board[row][col] = null;
					const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
					if (elem) {
						elem.classList.remove('lightning-strike');
						elem.style.opacity = '0';
						elem.style.transform = 'scale(0)';
					}
				}
				
				await new Promise(resolve => setTimeout(resolve, 200));
				
				// Drop gems and fill spaces
				await this.dropGems();
				await this.fillEmptySpaces();
				
				// Process any matches that resulted from the lightning storm
				await this.processMatches();
				
				// Update UI and check game state
				this.updateUI();
				this.checkGameState();
				
				// Re-enable interactions
				this.animating = false;
				
				console.log('=== LIGHTNING STORM COMPLETE ===');
			}

			async applyVoidCollapse() {
				if (!this.pendingConsumable) return;
				
				// Disable interactions
				this.animating = true;
				this.disableAllInteractions();
				
				this.consumableInventory[this.pendingConsumable.id]--;
				this.saveConsumableInventory();
				this.updateConsumablesDisplay();
				
				// Clear pending consumable
				this.pendingConsumable = null;
				
				// Find the lowest value gem
				let lowestValue = Infinity;
				for (let row = 0; row < 7; row++) {
					for (let col = 0; col < 7; col++) {
						const gem = this.board[row][col];
						if (gem && gem.value < lowestValue) {
							lowestValue = gem.value;
						}
					}
				}
				
				// Remove all gems with the lowest value
				const collapsedGems = [];
				for (let row = 0; row < 7; row++) {
					for (let col = 0; col < 7; col++) {
						const gem = this.board[row][col];
						if (gem && gem.value === lowestValue) {
							this.board[row][col] = null;
							collapsedGems.push({row, col});
							
							const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
							if (elem) {
								elem.style.opacity = '0';
								elem.style.transform = 'scale(0)';
							}
						}
					}
				}
				
				this.showComboIndicator(`üï≥Ô∏è VOID COLLAPSE! Removed ${collapsedGems.length} gems!`);
				this.playSound('void');
				
				await new Promise(resolve => setTimeout(resolve, 300));
				
				await this.dropGems();
				await this.fillEmptySpaces();
				
				// Process any matches that resulted from the collapse
				await this.processMatches();
				
				// Update UI and check game state
				this.updateUI();
				this.checkGameState();
				
				// Re-enable interactions
				this.animating = false;
				this.enableAllInteractions();
			}

			async applyGemForge() {
				if (!this.pendingConsumable) return;
				
				// Disable interactions
				this.animating = true;
				this.disableAllInteractions();
				
				this.consumableInventory[this.pendingConsumable.id]--;
				this.saveConsumableInventory();
				this.updateConsumablesDisplay();
				
				// Clear pending consumable
				this.pendingConsumable = null;
				
				const gemsToUpgrade = [];
				for (let row = 0; row < 7; row++) {
					for (let col = 0; col < 7; col++) {
						const gem = this.board[row][col];
						if (gem) {
							gemsToUpgrade.push({row, col});
						}
					}
				}
				
				// Select 5 random gems to upgrade
				const selectedGems = [];
				while (selectedGems.length < 5 && gemsToUpgrade.length > 0) {
					const randomIndex = Math.floor(Math.random() * gemsToUpgrade.length);
					selectedGems.push(gemsToUpgrade.splice(randomIndex, 1)[0]);
				}
				
				// Upgrade the selected gems with visual effects
				for (const {row, col} of selectedGems) {
					if (this.board[row][col]) {
						this.board[row][col].value = 65;
						
						const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
						if (elem) {
							this.updateGemElement(elem, this.board[row][col]);
							elem.classList.add('special');
							
							// Add upgrade animation
							elem.style.transform = 'scale(1.3)';
							elem.style.transition = 'transform 0.3s ease';
							
							setTimeout(() => {
								elem.style.transform = 'scale(1)';
							}, 300);
						}
					}
				}
				
				this.showComboIndicator(`üî® GEM FORGE! Upgraded ${selectedGems.length} gems!`);
				this.playSound('relic');
				
				await new Promise(resolve => setTimeout(resolve, 300));
				
				// Check for any matches created by the upgrades
				await this.processMatches();
				
				// Update UI and check game state
				this.updateUI();
				this.checkGameState();
				
				// Re-enable interactions
				this.animating = false;
				this.enableAllInteractions();
			}

			async applyTimeFreeze() {
				if (!this.pendingConsumable) return;
				
				this.consumableInventory[this.pendingConsumable.id]--;
				this.saveConsumableInventory();
				this.updateConsumablesDisplay();
				
				// Clear pending consumable
				this.pendingConsumable = null;
				
				this.moves += 1;
				this.showComboIndicator('‚è∞ TIME FREEZE! +1 Move!');
				this.playSound('relic');
				this.updateUI();
			}

            updateBoostersDisplay() {
                // Active boosters
                const panel = document.getElementById('boostersPanel');
                const listContainer = document.getElementById('activeBoostersList');
                
                if (!panel || !listContainer) return;
                
                listContainer.innerHTML = '';
                
                let hasActiveBoosters = false;
                for (const boosterId in this.activeBoosters) {
                    if (this.activeBoosters[boosterId] > 0) {
                        hasActiveBoosters = true;
                        break;
                    }
                }
                
                if (hasActiveBoosters) {
                    panel.style.display = 'block';
                    
                    for (const boosterId in this.activeBoosters) {
                        if (this.activeBoosters[boosterId] > 0) {
                            const item = this.shopItems.boosters.find(b => b.id === boosterId);
                            if (item) {
                                const boosterDiv = document.createElement('div');
                                boosterDiv.className = 'active-booster';
                                boosterDiv.innerHTML = `
                                    <div class="booster-name">${item.name} (${this.activeBoosters[boosterId]} uses left)</div>
                                    <div class="booster-desc">${item.desc}</div>
                                `;
                                listContainer.appendChild(boosterDiv);
                            }
                        }
                    }
                } else {
                    panel.style.display = 'none';
                }

                // Available boosters from shop purchases
                this.updateAvailableBoostersDisplay();
            }

			updateAvailableBoostersDisplay() {
				// Don't update during animations to prevent re-enabling buttons
				if (this.interactionsDisabled || this.animating) {
					return;
				}
				
				const panel = document.getElementById('availableBoostersPanel');
				const buttonsContainer = document.getElementById('availableBoosterButtons');
				
				if (!panel || !buttonsContainer) return;
				
				buttonsContainer.innerHTML = '';
				
				let hasAvailableBoosters = false;
				for (const boosterId in this.runBoosters) {
					if (this.runBoosters[boosterId] > 0) {
						hasAvailableBoosters = true;
						break;
					}
				}
				
				if (hasAvailableBoosters) {
					panel.style.display = 'block';

					// show booster uses out of 4
					const hdr = panel.querySelector('h4');
					if (hdr) hdr.textContent = `üí´ Available Boosters (${this.boosterUsesThisFloor}/4)`;

					for (const boosterId in this.runBoosters) {
						if (this.runBoosters[boosterId] > 0) {
							const item = this.shopItems.boosters.find(b => b.id === boosterId);
							if (item) {
								const button = document.createElement('button');
								button.className = 'booster-btn';
								
								// Check if score shield is already used this floor
								const isScoreShieldUsed = boosterId === 'score_shield' && this.activeBoosters['score_shield_used_this_floor'];
								
								if (isScoreShieldUsed) {
									button.disabled = true;
									button.innerHTML = `
										<div>${item.name} (Used this floor)</div>
										<div class="booster-description">${item.desc}</div>
									`;
								} else {
									button.innerHTML = `
										<div>${item.name}</div>
										<div class="booster-description">${item.desc}</div>
									`;
									button.onclick = () => this.activateBooster(boosterId);
								}
								
								// Apply disabled state if interactions are disabled
								if (this.interactionsDisabled || this.animating) {
									button.disabled = true;
									button.style.opacity = '0.5';
									button.style.cursor = 'not-allowed';
									button.style.pointerEvents = 'none';
								}
								
								button.dataset.boosterId = boosterId;
								
								const countSpan = document.createElement('span');
								countSpan.className = 'booster-count';
								countSpan.textContent = this.runBoosters[boosterId];
								button.appendChild(countSpan);
								
								buttonsContainer.appendChild(button);
							}
						}
					}
				} else {
					panel.style.display = 'none';
				}
			}
			
			activateBooster(boosterId) {
				if (!this.runBoosters[boosterId] || this.runBoosters[boosterId] <= 0) return;
				
				const item = this.shopItems.boosters.find(b => b.id === boosterId);
				if (!item) return;
				
				// Check if booster is already active
				if (this.activeBoosters[boosterId] && this.activeBoosters[boosterId] > 0) {
					this.showComboIndicator('‚ö†Ô∏è Booster already active!');
					return;
				}
				
				// Consume one booster from inventory
				this.runBoosters[boosterId]--;
				this.saveRunBoosters();
				
				// Apply the booster effect based on type
				switch (boosterId) {
					case 'gem_transmuter':
						// Give 1 transmutation use
						this.activeBoosters['gem_transmuter'] = 1;
						this.showComboIndicator('üîÑ GEM TRANSMUTER READY! (1 use)');
						break;
						
					case 'lucky_streak':
						// Give 3 lucky match chances
						this.activeBoosters['lucky_streak'] = 3;
						this.showComboIndicator('üçÄ LUCKY STREAK ACTIVATED! (3 matches)');
						break;
						
					case 'score_shield':
						// Check if already used this floor
						if (this.activeBoosters['score_shield_used_this_floor']) {
							this.showComboIndicator('üõ°Ô∏è Score Shield already used this floor!');
							return; // Don't consume the booster
						}
						
						// Store the original target score if not already stored
						if (!this.originalTargetScore) {
							this.originalTargetScore = this.targetScore;
						}
						
						// Apply temporary reduction
						this.targetScore = Math.floor(this.originalTargetScore * 0.5);
						this.activeBoosters['score_shield_used_this_floor'] = true;
						this.showComboIndicator('üõ°Ô∏è SCORE SHIELD ACTIVATED! (This floor only)');
						this.updateUI();
						break;
						
					case 'cascade_catalyst':
						// Give 1 guaranteed cascade
						this.activeBoosters['cascade_catalyst'] = 1;
						this.showComboIndicator('üåä CASCADE CATALYST PRIMED! (1 use)');
						break;
				}

				// track and charge move every 4 boosters this floor
				this.boosterUsesThisFloor++;
				if (this.boosterUsesThisFloor >= 4) {
				  this.boosterUsesThisFloor -= 4;
				  this.moves--;
				  this.showComboIndicator('‚ö° 4 boosters used ‚Üí ‚Äì1 Move');
				  this.updateUI();
				}

				this.updateBoostersDisplay();
			}

			resetBoosterCooldowns() {
				// Reset score shield usage for new floor
				if (this.activeBoosters['score_shield_used_this_floor']) {
					delete this.activeBoosters['score_shield_used_this_floor'];
				}
				
				// Reset target score to normal calculation for new floor
				this.originalTargetScore = null;
				
				this.updateBoostersDisplay();
			}

			resetMatchCooldowns() {
				// Reset cascade catalyst cooldown after each match
				if (this.activeBoosters['cascade_catalyst'] === -1) {
					delete this.activeBoosters['cascade_catalyst'];
				}
				
				this.updateBoostersDisplay();
			}

            applyGemTheme() {
                if (this.purchasedUpgrades['gem_theme_neon']) {
                    const gems = document.querySelectorAll('.gem');
                    gems.forEach(gem => {
                        gem.classList.add('neon-theme');
                    });
                }
            }

            applyBoardTheme() {
                if (this.purchasedUpgrades['board_theme_space']) {
                    const gameBoard = document.getElementById('gameBoard');
                    gameBoard.classList.add('space-theme');
                }
            }
            
            initializeGame() {
                this.applyPermanentUpgrades();
                this.createBoard();
				document.querySelectorAll('.gem').forEach(el => {
				  el.style.gridRowStart    = +el.dataset.row + 1;
				  el.style.gridColumnStart = +el.dataset.col + 1;
				});
                this.updateUI();
                this.addEventListeners();
                this.initializeScoreDisplay();
                this.updateCrystalDisplay();
                this.updateConsumablesDisplay();
                this.updateBoostersDisplay();
                
                // Start background music and show audio toggle
                this.playBackgroundMusic('bg1');
                this.showIngameAudioToggle();
            }

            initializeScoreDisplay() {
                this.displayScore = this.score;
                this.updateScoreDisplay();
            }

			updateScoreDisplay() {
			  const scoreDisplay = document.getElementById('scoreDisplay');
			  if (scoreDisplay) {
				scoreDisplay.textContent = formatNumber(Math.floor(this.displayScore));
			  }
			}

            animateScoreIncrease(amount) {
                // Show popup with the amount being added
                this.showScorePopup(amount);

                // Animate score counter
                const startScore = this.displayScore;
                const endScore = this.score;
                const duration = 600;
                const startTime = Date.now();

                const animateScore = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    this.displayScore = startScore + (endScore - startScore) * progress;
                    this.updateScoreDisplay();

                    if (progress < 1) {
                        requestAnimationFrame(animateScore);
                    }
                };

                requestAnimationFrame(animateScore);
            }

			showScorePopup(amount) {
				const scoreDisplay = document.getElementById('scoreDisplay');
				if (!scoreDisplay) return;

				// Initialize queue if it doesn't exist
				if (!this.scorePopupQueue) {
					this.scorePopupQueue = [];
					this.isProcessingPopups = false;
				}

				this.scorePopupQueue.push(amount);

				if (!this.isProcessingPopups) {
					this.processScorePopupQueue();
				}
			}

			async processScorePopupQueue() {
				if (this.scorePopupQueue.length === 0) {
					this.isProcessingPopups = false;
					return;
				}

				this.isProcessingPopups = true;
				const amount = this.scorePopupQueue.shift();

				const scoreDisplay = document.getElementById('scoreDisplay');
				if (!scoreDisplay) {
					this.processScorePopupQueue();
					return;
				}

				const scorePopup = document.createElement('div');
				scorePopup.className = 'score-popup';
				scorePopup.textContent = `+${formatNumber(Math.floor(amount))}`;
				scorePopup.style.position = 'fixed';
				scorePopup.style.zIndex = '9999';
				
				const rect = scoreDisplay.getBoundingClientRect();
				const textWidth = scoreDisplay.offsetWidth;

				scorePopup.style.left = (rect.left + textWidth - 135) + 'px';
				scorePopup.style.top = (rect.top + 5) + 'px';
				
				document.body.appendChild(scorePopup);
				
				scorePopup.offsetHeight;
				scorePopup.classList.add('animate');
				
				// Clean up after animation
				setTimeout(() => {
					if (scorePopup.parentNode) {
						scorePopup.parentNode.removeChild(scorePopup);
					}
				}, 1200);

				// Process next popup much faster - only 150ms delay instead of 1200ms
				setTimeout(() => {
					this.processScorePopupQueue();
				}, 150);
			}

            updateComboDisplay() {
                const comboDisplay = document.getElementById('comboDisplay');
                if (comboDisplay) {
                    if (this.isCurrentlyScoring && this.currentCombo >= 1) {
                        comboDisplay.textContent = `Combo x${this.currentCombo}`;
                        comboDisplay.classList.add('show');
                    } else {
                        comboDisplay.classList.remove('show');
                    }
                }
            }

            hideComboDisplay() {
                const comboDisplay = document.getElementById('comboDisplay');
                if (comboDisplay) {
                    comboDisplay.classList.remove('show', 'pulse');
                }
                this.isCurrentlyScoring = false;
            }

            showScoreDisplayWithKablaam() {
                const scoreDisplay = document.getElementById('scoreDisplay');
                
                if (scoreDisplay) {
                    scoreDisplay.classList.remove('wibble', 'kablaam');
                    scoreDisplay.offsetHeight;
                    scoreDisplay.classList.add('kablaam');
                }
            }

            showScoreDisplayWithWibble() {
                const scoreDisplay = document.getElementById('scoreDisplay');
                if (scoreDisplay) {
                    scoreDisplay.classList.remove('kablaam');
                    scoreDisplay.offsetHeight;
                    scoreDisplay.classList.add('wibble');
                }
            }

			createBoard() {
				const gameBoard = document.getElementById('gameBoard');
				gameBoard.innerHTML = '';
				this.board = [];
				
				// Disable gem switching AND consumables during board creation
				this.animating = true;
				this.disableAllInteractions();
				
				this.generateValidBoard();
				
				for (let row = 0; row < 7; row++) {
					for (let col = 0; col < 7; col++) {
						const gem = this.board[row][col];
						
						const gemElement = document.createElement('div');
						gemElement.className = `gem ${gem.type}`;
						if (gem.value >= 50) {
							gemElement.classList.add('special');
						}
						gemElement.textContent = gem.symbol;
						gemElement.dataset.row = row;
						gemElement.dataset.col = col;
						gemElement.dataset.gemId = gem.id;  
						const valueDisplay = document.createElement('div');
						valueDisplay.className = 'gem-value-display';
						valueDisplay.textContent = gem.value;
						gemElement.appendChild(valueDisplay);
						
						gemElement.style.transform = 'translateY(-420px)';
						gemElement.style.opacity = '0';
						
						gameBoard.appendChild(gemElement);
						
						setTimeout(() => {
							gemElement.style.transition = 'transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s ease';
							gemElement.style.transform = 'translateY(0)';
							gemElement.style.opacity = '1';
							
							// Play place sound for each gem
							setTimeout(() => {
								if (this.audioEnabled) {
									this.playSound('place');
								}
							}, 50);
						}, (row * 7 + col) * 80);
					}
				}
				
				// After all gems are placed, create wave effect
				const totalPlacementTime = (7 * 7 - 1) * 80 + 600; // Last gem delay + animation time

				setTimeout(() => {
					this.createWaveEffect();
				}, totalPlacementTime + 200);

				// Calculate total time for wave effect completion
				const waveCompletionTime = totalPlacementTime + 200 + (6 + 6) * 33 + 220 + (49 * 9) + 275;
				
				// Re-enable ALL interactions after wave completes
				setTimeout(() => {
					this.animating = false;
					this.enableAllInteractions();
				}, waveCompletionTime);
				
				// Apply cosmetic themes after board creation
				setTimeout(() => {
					this.applyCurrentCosmetics();
				}, 1000);
			}

			createWaveEffect() {
				const gameBoard = document.getElementById('gameBoard');
				const gems = gameBoard.querySelectorAll('.gem');
				
				// Create wave pattern - diagonal sweep from bottom-right to top-left
				for (let row = 0; row < 7; row++) {
					for (let col = 0; col < 7; col++) {
						const gem = gems[row * 7 + col];
						if (gem) {
							// Calculate delay for bottom-right to top-left wave (10% slower)
							const waveDelay = ((6 - row) + (6 - col)) * 33; // Changed from 30 to 33
							
							setTimeout(() => {
								// Wave effect - brief upward movement (10% slower)
								gem.style.transition = 'transform 0.165s ease-out'; // Changed from 0.15s to 0.165s
								gem.style.transform = 'translateY(-15px) scale(1.05)';
								
								setTimeout(() => {
									// Return to normal position with wobble (10% slower)
									gem.style.transition = 'transform 0.22s cubic-bezier(0.68, -0.55, 0.265, 1.55)'; // Changed from 0.2s to 0.22s
									gem.style.transform = 'translateY(0) scale(1)';
								}, 83); // Changed from 75 to 83
							}, waveDelay);
						}
					}
				}
				
				// Final settling wobble for all gems (10% slower)
				setTimeout(() => {
					gems.forEach((gem, index) => {
						setTimeout(() => {
							gem.style.transition = 'transform 0.275s cubic-bezier(0.68, -0.55, 0.265, 1.55)'; // Changed from 0.25s to 0.275s
							gem.style.transform = 'scale(1.02)';
							
							setTimeout(() => {
								gem.style.transition = 'transform 0.165s ease-out'; // Changed from 0.15s to 0.165s
								gem.style.transform = 'scale(1)';
								
								// Clear any inline styles after animation
								setTimeout(() => {
									gem.style.transition = '';
									gem.style.transform = '';
								}, 165); // Changed from 150 to 165
							}, 110); // Changed from 100 to 110
						}, index * 9); // Changed from 8 to 9
					});
				}, (6 + 6) * 33 + 220); // Updated calculation for new timing
			}

            generateValidBoard() {
                for (let row = 0; row < 7; row++) {
                    this.board[row] = [];
                    for (let col = 0; col < 7; col++) {
                        this.board[row][col] = null;
                    }
                }
                
                for (let row = 0; row < 7; row++) {
                    for (let col = 0; col < 7; col++) {
                        let gem;
                        let attempts = 0;
                        
                        do {
                            gem = this.createRandomGem();
                            attempts++;
                            if (attempts > 50) break;
                        } while (this.wouldCreateMatch(row, col, gem.type));
                        
                        this.board[row][col] = gem;
                    }
                }
            }

            wouldCreateMatch(row, col, gemType) {
                let leftCount = 0;
                for (let c = col - 1; c >= 0; c--) {
                    if (this.board[row][c] && this.board[row][c].type === gemType) {
                        leftCount++;
                    } else {
                        break;
                    }
                }
                
                let rightCount = 0;
                for (let c = col + 1; c < 7; c++) {
                    if (this.board[row][c] && this.board[row][c].type === gemType) {
                        rightCount++;
                    } else {
                        break;
                    }
                }
                
                let upCount = 0;
                for (let r = row - 1; r >= 0; r--) {
                    if (this.board[r][col] && this.board[r][col].type === gemType) {
                        upCount++;
                    } else {
                        break;
                    }
                }
                
                let downCount = 0;
                for (let r = row + 1; r < 7; r++) {
                    if (this.board[r][col] && this.board[r][col].type === gemType) {
                        downCount++;
                    } else {
                        break;
                    }
                }
                
                return (leftCount + rightCount >= 2) || (upCount + downCount >= 2);
            }

            createRandomGem() {
                const type = this.gemTypes[Math.floor(Math.random() * this.gemTypes.length)];
                let baseValue = Math.floor(Math.random() * 25) + 15;
                
                if (this.luckyCharm && Math.random() < 0.4) {
                    baseValue += 25;
                }
                
                baseValue = Math.floor(baseValue * this.gemValueBoost);
                
                const gem = {
                    type: type,
                    symbol: this.gemSymbols[type],
                    value: baseValue,
                    isThunderbolt: false,
                    strikeCount: 0
                };
                
				return {
					id: _nextGemId++,           // <-- unique
					type,
					symbol: this.gemSymbols[type],
					value: baseValue,
					isThunderbolt: false,
					strikeCount: 0
				};
            }

			addEventListeners() {
				const gameBoard = document.getElementById('gameBoard');
				gameBoard.addEventListener('click', (e) => {
					// Check if interactions are disabled OR if animating OR if no moves left
					if (this.interactionsDisabled || this.animating || this.moves <= 0) {
						console.log('Gem clicks disabled:', {
							interactionsDisabled: this.interactionsDisabled,
							animating: this.animating,
							moves: this.moves
						});
						return;
					}
					
					const gemElement = e.target.closest('.gem');
					if (!gemElement) return;
					
					const row = parseInt(gemElement.dataset.row);
					const col = parseInt(gemElement.dataset.col);
					
					// Check for gem transmuter booster FIRST
					if (this.activeBoosters['gem_transmuter'] && this.activeBoosters['gem_transmuter'] > 0) {
						this.showGemTransmuterModal(row, col);
						return;
					}
					
					if (this.selectedGem) {
						if (this.selectedGem.row === row && this.selectedGem.col === col) {
							this.clearSelection();
						} else if (this.isAdjacent(this.selectedGem, {row, col})) {
							this.swapGems(this.selectedGem, {row, col});
						} else {
							this.selectGem(row, col);
						}
					} else {
						this.selectGem(row, col);
					}
				});
			}

            selectGem(row, col) {
                this.clearSelection();
                this.selectedGem = {row, col};
                const gemElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                gemElement.classList.add('selected');
            }

            clearSelection() {
                if (this.selectedGem) {
                    const gemElement = document.querySelector(`[data-row="${this.selectedGem.row}"][data-col="${this.selectedGem.col}"]`);
                    if (gemElement) {
                        gemElement.classList.remove('selected');
                    }
                }
                this.selectedGem = null;
            }

            isAdjacent(gem1, gem2) {
                const rowDiff = Math.abs(gem1.row - gem2.row);
                const colDiff = Math.abs(gem1.col - gem2.col);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            async swapGems(gem1, gem2) {
                this.animating = true;
                
                this.playSound('swap');
                
                const elem1 = document.querySelector(`[data-row="${gem1.row}"][data-col="${gem1.col}"]`);
                const elem2 = document.querySelector(`[data-row="${gem2.row}"][data-col="${gem2.col}"]`);
                
                const rect1 = elem1.getBoundingClientRect();
                const rect2 = elem2.getBoundingClientRect();
                
                const deltaX = rect2.left - rect1.left;
                const deltaY = rect2.top - rect1.top;
                
                elem1.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                elem2.style.transform = `translate(${-deltaX}px, ${-deltaY}px)`;
                
                await new Promise(resolve => setTimeout(resolve, 200));
                
                const temp = this.board[gem1.row][gem1.col];
                this.board[gem1.row][gem1.col] = this.board[gem2.row][gem2.col];
                this.board[gem2.row][gem2.col] = temp;
                
                const matches = this.findMatches();
                
                if (matches.length === 0) {
                    this.board[gem2.row][gem2.col] = this.board[gem1.row][gem1.col];
                    this.board[gem1.row][gem1.col] = temp;
                    
                    elem1.style.transform = '';
                    elem2.style.transform = '';
                    
                    this.clearSelection();
                    this.animating = false;
                    return;
                }
                
                this.moves--;
                document.getElementById('movesLeft').textContent = this.moves;

				// Check for lucky streak booster
				if (this.activeBoosters['lucky_streak'] && this.activeBoosters['lucky_streak'] > 0) {
					// Always consume one use
					this.activeBoosters['lucky_streak']--;
					
					if (Math.random() < 0.5) {
						this.moves++; // Refund the move
						const remainingUses = this.activeBoosters['lucky_streak'];
						if (remainingUses > 0) {
							this.showComboIndicator(`üçÄ LUCKY STREAK! (${remainingUses} left)`);
						} else {
							this.showComboIndicator('üçÄ LUCKY STREAK! (expired)');
							delete this.activeBoosters['lucky_streak'];
						}
					} else {
						const remainingUses = this.activeBoosters['lucky_streak'];
						if (remainingUses > 0) {
							this.showComboIndicator(`üçÄ LUCK FAILED! (${remainingUses} left)`);
						} else {
							this.showComboIndicator('üçÄ LUCK FAILED! (expired)');
							delete this.activeBoosters['lucky_streak'];
						}
					}
					
					this.updateBoostersDisplay();
				}

				// Check for cascade catalyst booster
				if (this.activeBoosters['cascade_catalyst'] && this.activeBoosters['cascade_catalyst'] > 0) {
					// Set cooldown until next match
					this.activeBoosters['cascade_catalyst'] = -1;
					this.showComboIndicator('üåä CASCADE CATALYST TRIGGERED! (Cooldown until next match)');
					this.updateBoostersDisplay();
				}
                
                if (this.diceOfFate && Math.random() < 0.15) {
                    this.showComboIndicator('üé≤ LUCKY! FREE MOVE!');
                    this.moves++;
                }

                if (this.timeDilator) {
                    this.targetScore = Math.max(this.targetScore * 0.9, this.targetScore - 25);
                    this.showComboIndicator('‚è∞ TARGET -25!');
                }
                
                this.updateGemElement(elem1, this.board[gem1.row][gem1.col]);
                this.updateGemElement(elem2, this.board[gem2.row][gem2.col]);
                
                elem1.style.transform = '';
                elem2.style.transform = '';
                
                this.clearSelection();
                
                this.isCurrentlyScoring = false;
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                await this.processMatches();
                
                this.updateUI();
                this.checkGameState();
                this.animating = false;
				this.resetMatchCooldowns();
            }

			updateGemElement(element, gem) {
			  // remember if neon was on
			  const neonOn = element.classList.contains('neon-theme');

			  // strip out any old type classes and re-add just ‚Äúgem‚Äù + the type
			  element.classList.remove(...this.gemTypes);
			  element.classList.add('gem', gem.type);

			  // reapply neon if needed
			  if (neonOn) element.classList.add('neon-theme');

			  // then your other flags
			  if (gem.value >= 50) element.classList.add('special');
			  if (gem.isThunderbolt) element.classList.add('thunderbolt');

			  element.textContent = gem.symbol;

			  // update the little value-display
			  let vd = element.querySelector('.gem-value-display');
			  if (!vd) {
				vd = document.createElement('div');
				vd.className = 'gem-value-display';
				element.appendChild(vd);
			  }
			  vd.textContent = formatNumber(gem.value);
			}

            updateUI() {
				document.getElementById('scoreDisplay').textContent = formatNumber(this.score);
				document.getElementById('movesLeft').textContent = formatNumber(this.moves);
				document.getElementById('currentFloor').textContent = formatNumber(this.floor);
				document.getElementById('targetScore').textContent = formatNumber(this.targetScore);
				document.getElementById('multiplier').textContent = this.multiplier.toFixed(1) + 'x';
                
                const progress = Math.min(100, (this.score / this.targetScore) * 100);
                document.getElementById('progressFill').style.width = progress + '%';

				const cu = document.getElementById('consumableUsesDisplay');
				if (cu) cu.textContent = `${this.consumableUsesThisFloor}/2`;
				const bu = document.getElementById('boosterUsesDisplay');
				if (bu) bu.textContent = `${this.boosterUsesThisFloor}/4`;
				this.applyCurrentCosmetics();
            }

            checkGameState() {
                if (this.moves <= 0) {
                    if (this.score >= this.targetScore) {
                        // Award crystals for overage
                        const crystalGain = this.calculateCrystalGain(this.score, this.targetScore);
                        if (crystalGain > 0) {
                            this.awardCrystals(crystalGain);
                        }
                        this.nextFloor();
                    } else {
                        this.showGameOver();
                    }
                }
            }

			nextFloor() {
				this.floor++;

				this.consumableUsesThisFloor = 0;
				this.boosterUsesThisFloor = 0;

				// Calculate NEW target score based on floor progression (not reduced score)
				const baseTargetScore = Math.floor(800 * Math.pow(1.45, this.floor - 1));
				this.targetScore = baseTargetScore;
				this.multiplier += 0.15;
				
				// Handle score overflow if purchased
				let carryoverScore = 0;
				if (this.purchasedUpgrades['score_overflow'] && this.score > this.targetScore) {
					const excess = this.score - this.targetScore;
					carryoverScore = Math.floor(excess * 0.01);
				}
				
				this.score = carryoverScore;
				this.displayScore = carryoverScore;
				
				// Reset floor-based cooldowns AFTER setting new target
				this.resetBoosterCooldowns();
				
				this.showRelicSelection();
				this.floorEntropyCascades = 0;
			}
			
			async applyTimeFreeze() {
				if (!this.pendingConsumable) return;
				
				this.consumableInventory[this.pendingConsumable.id]--;
				this.saveConsumableInventory();
				this.updateConsumablesDisplay();
				
				this.moves += 1;
				this.updateUI();
			}
			
            showRelicSelection() {
                // Show shop first if player has crystals
                if (this.crystals > 0) {
                    this.openShop();
                    return;
                }
                
                // If no crystals, go directly to relic selection
                this.actuallyShowRelicSelection();
            }

			selectRelic(relic) {
			   this.playSound('relic');
			   if (relic.type !== 'continue') {
				    this.relics.push(relic);
				    relic.effect();
				    const el = document.getElementById('relicsList').lastElementChild;
				    if (el) {
		 			    const map = {
		 				    jester_gambit:    'jester-effect',
		 				    quantum_mirror:   'quantum-mirror-effect',
		 		 		    entropy_engine:   'entropy-engine-effect'
		 			    };
		 			    el.classList.add(map[relic.type]);
		 		    }
			    }
			    this.moves = 4 + (this.bonusMoves || 0);
			    document.getElementById('relicSelectionScreen').style.display = 'none';
			    this.createBoard();
				document.querySelectorAll('.gem').forEach(el => {
				  el.style.gridRowStart    = +el.dataset.row + 1;
				  el.style.gridColumnStart = +el.dataset.col + 1;
				});

			    this.updateUI();
			    this.updateRelicsDisplay();
			    this.initializeScoreDisplay();
			}

			updateRelicsDisplay() {
			  const relicsList = document.getElementById('relicsList');
			  const container  = document.querySelector('.active-relics-container');

			  // clear out old relics
			  relicsList.innerHTML = '';

			  // add each relic as its own <div class="relic">‚Ä¶
			  this.relics.forEach(relic => {
				const relicDiv = document.createElement('div');
				relicDiv.className = 'relic';

				// fill in name + description
				relicDiv.innerHTML = `
				  <div class="relic-name">${relic.name}</div>
				  <div class="relic-desc">${relic.desc}</div>
				`;
				relicsList.appendChild(relicDiv);
			  });

			  // toggle the ‚Äútwo-rows‚Äù class if you‚Äôve got more than 3 relics
			  if (this.relics.length > 3) {
				container.classList.add('two-rows');
			  } else {
				container.classList.remove('two-rows');
			  }
			}

            showComboIndicator(text) {
                const indicator = document.getElementById('comboIndicator');
                indicator.textContent = text;
                indicator.classList.add('show');
                
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 1000);
            }

			showGameOver() {
				this.disableAllInteractions();
				console.log('showGameOver called - stopping all music');
				
				// Stop ALL background music immediately
				this.stopBackgroundMusic();
				
				// Play lose sound
				this.playSound('lose');
				
				const gameOverScreen = document.getElementById('gameOverScreen');
				const floorResult     = document.getElementById('floorResult');
				const restartBtn      = gameOverScreen.querySelector('button[onclick="restartGame()"]');
				const menuBtn         = gameOverScreen.querySelector('button[onclick="returnToStart()"]');

				// Disable both buttons immediately
				restartBtn.disabled = true;
				menuBtn.disabled    = true;
				restartBtn.style.opacity = '0.5';
				menuBtn.style.opacity    = '0.5';
				
				gameOverScreen.querySelector('h2').textContent = 'Game Over!';
				floorResult.textContent = 
				  `Floor ${this.floor} Failed. You needed ${this.targetScore} points but only scored ${this.score}.`;
				gameOverScreen.style.display = 'block';
				
				// wait for your lose‚Äêto‚Äêgameover transition to finish
				setTimeout(() => {
				  if (this.audioEnabled && this.sounds && this.sounds.gameover) {
					this.sounds.gameover.volume = this.musicVolume / 100;
					this.playBackgroundMusic('gameover');
				  }

				  // now that cleanup & music have started, re‚Äêenable buttons
				  restartBtn.disabled = false;
				  menuBtn.disabled    = false;
				  restartBtn.style.opacity = '';
				  menuBtn.style.opacity    = '';
				}, 1500);
			}

            // Add all the missing match processing methods here...
            async processMatches() {
				this.disableAllInteractions();
                let totalMatches = 0;
                let comboMultiplier = 1;
				this.isCurrentlyScoring = false;
                this.cascadeCount = 0;
                this.currentCombo = 0;
                
                while (true) {
                    const matches = this.findMatches();
                    if (matches.length === 0) break;
                    
                    if (!this.isCurrentlyScoring) {
                        this.showScoreDisplayWithKablaam();
                        this.isCurrentlyScoring = true;
                    } else {
                        this.showScoreDisplayWithWibble();
                    }
                    
                    this.playSound('clear');
                    
                    totalMatches += matches.length;
                    this.matchCounter++;
                    this.cascadeCount++;
                    this.currentCombo++;
                    
                    this.updateComboDisplay();

                    if (this.voidHunger) {
                        await this.processVoidHunger(matches);
                    }

                    if (this.stormSurge) {
                        await this.processStormSurge(matches);
                    }
                    
                    // Process explosive matches
					if (this.explosiveMatches && matches.length >= 4) {
						await this.handleExplosiveMatches(matches);
					}
                    
                    for (const match of matches) {
                        const elem = document.querySelector(`[data-row="${match.row}"][data-col="${match.col}"]`);
                        if (elem) {
                            const gem = this.board[match.row][match.col];
                            let wasExplosive = false;
                            
                            if (this.explosiveMatches && matches.length >= 4 && gem) {
                                const sameTypeCount = matches.filter(m => {
                                    const matchGem = this.board[m.row][m.col];
                                    return matchGem && matchGem.type === gem.type;
                                }).length;
                                
                                wasExplosive = sameTypeCount >= 4;
                            }
                            
                            if (!wasExplosive) {
                                elem.classList.add('matching');
                            }
                        }
                    }
                    
                    
                    let matchScore = 0;
                    for (const match of matches) {
                        let gemValue = this.board[match.row][match.col] ? this.board[match.row][match.col].value : 0;
                        let gemType = this.board[match.row][match.col] ? this.board[match.row][match.col].type : null;
                        
                        if (gemValue > 0) {
                            if (gemType === 'fire' && this.fireBoost > 1) {
                                gemValue *= this.fireBoost;
                            }
                            if (gemType === 'lightning' && this.lightningBoost > 1) {
                                gemValue *= this.lightningBoost;
                            }
                            if (gemType === 'void' && this.voidBoost > 1) {
                                gemValue *= this.voidBoost;
                            }
                            
                            matchScore += gemValue * (comboMultiplier * this.comboBoost);
                        }
                        
                        this.board[match.row][match.col] = null;
                    }
                    
                    if (this.gemAlchemy && this.matchCounter % 3 === 0 && matches.length > 0) {
                        const firstMatch = matches[0];
                        const firstElem = document.querySelector(`[data-row="${firstMatch.row}"][data-col="${firstMatch.col}"]`);
                        let targetType = null;
                        
                        for (const type of this.gemTypes) {
                            if (firstElem && firstElem.classList.contains(type)) {
                                targetType = type;
                                break;
                            }
                        }
                        
                        if (targetType) {
                            for (let row = 0; row < 7; row++) {
                                for (let col = 0; col < 7; col++) {
                                    if (this.board[row][col] && this.board[row][col].type === targetType) {
                                        this.board[row][col].value = 65;
                                    }
                                }
                            }
                            this.showComboIndicator('üß™ ALCHEMY ACTIVATED!');
                        }
                    }
                    
                    if (this.cascadeMaster && this.cascadeCount > 1 && this.cascadeCount % 2 === 0) {
                        this.baseMultiplier += 0.1;
                        this.showComboIndicator('üåä CASCADE MASTERY!');
                    }
                    
                    const finalMatchScore = Math.floor(matchScore * this.multiplier * this.baseMultiplier);
                    this.score += finalMatchScore;
                    this.animateScoreIncrease(finalMatchScore);
                    
                    for (const match of matches) {
                        const elem = document.querySelector(`[data-row="${match.row}"][data-col="${match.col}"]`);
                        if (elem) {
                            const gem = this.board[match.row][match.col];
                            let wasExplosive = false;
                            
                            if (this.explosiveMatches && matches.length >= 4 && gem) {
                                const sameTypeCount = matches.filter(m => {
                                    const matchGem = this.board[m.row] && this.board[m.row][m.col];
                                    return matchGem && matchGem.type === gem.type;
                                }).length;
                                
                                wasExplosive = sameTypeCount >= 4;
                            }
                            
                            if (!wasExplosive) {
								elem.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                                elem.style.opacity = '0';
                                elem.style.transform = 'scale(0)';
                            }
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));

					if (this.activeParticleEffects) {
					  const containerRect = this.particleContainer.getBoundingClientRect();

					  matches.forEach(({row, col}) => {
						const gemEl = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
						if (!gemEl) return;

						const { left, top, width, height } = gemEl.getBoundingClientRect();
						const cx = left + width/2  - containerRect.left;
						const cy = top  + height/2 - containerRect.top;

						// spawn larger star sparkles
						const count = 50;
						for (let i = 0; i < count; i++) {
						  const star = document.createElement('div');
						  star.className = 'sparkle-particle';

						  // random size 10‚Äì20px
						  const size = 10 + Math.random()*10;
						  star.style.setProperty('--size', `${size}px`);

						  // random duration 500‚Äì900ms
						  star.style.setProperty('--duration', `${500 + Math.random()*400}ms`);

						  // random direction & distance 100‚Äì180px
						  const angle = Math.random() * Math.PI * 2;
						  const dist  = 100 + Math.random() * 80;
						  star.style.setProperty('--dx', `${Math.cos(angle)*dist}px`);
						  star.style.setProperty('--dy', `${Math.sin(angle)*dist}px`);

						  star.style.left = `${cx}px`;
						  star.style.top  = `${cy}px`;

						  this.particleContainer.appendChild(star);
						  star.addEventListener('animationend', () => star.remove(), { once: true });
						}
					  });
					}
					
                    await this.dropGems();
                    await this.fillEmptySpaces();

					const rows = [...new Set(matches.map(m => m.row))];
	
					// 4) Jester's Gambit (üé≠ every 4 matches)
					if (this.jesterGambit) {
					  this.matchRoundsSinceJester = (this.matchRoundsSinceJester || 0) + 1;
					  // fire on every *even* round:
					  if (this.matchRoundsSinceJester % 4 === 0) {
						await this.animateJesterGambit(rows);
					  }
					}

					// 5) Quantum Mirror (üîÆ)
					if (this.quantumMirror && this.lastMatchPattern) {
					  // raw total of the mirrored gems
					  const rawMirror = this.lastMatchPattern.reduce(
						(sum, m) => sum + (this.board[m.row]?.[m.col]?.value || 0),
						0
					  );
					  // apply floor multiplier, base multiplier, and current combo
					  const finalMirror = Math.floor(
						rawMirror
						* this.multiplier
						* this.baseMultiplier
						* (this.currentCombo || 1)
					  );
					  this.score += finalMirror;
					  this.animateScoreIncrease(finalMirror);
					}

					// 6) Entropy Engine (‚öôÔ∏è every 5 cascades)
					if (this.entropyEngine) {
					  this.floorEntropyCount = (this.floorEntropyCount || 0) + 1;

					  if (this.floorEntropyCount % 5 === 0) {
						// 1) block until any in-flight shuffleBoard() is done
						while (this._isShuffling) {
						  await new Promise(r => setTimeout(r, 50));
						}
						// 2) now do the full fling-out + settle
						await this.shuffleBoard();

						// 3) refill as usual
						await this.dropGems();
						await this.fillEmptySpaces();
					  }
					}


					// store pattern for next iteration
					this.lastMatchPattern = matches.slice();

					// Wait out removal animations, then refill
					await new Promise(res => setTimeout(res, 20));
					await this.dropGems();
					await this.fillEmptySpaces();

					comboMultiplier += 1;

                }
                
                this.hideComboDisplay();
				this.enableAllInteractions();
            }

            findMatches() {
                const matches = [];
                const visited = new Set();
                
                for (let row = 0; row < 7; row++) {
                    let count = 1;
                    let currentType = this.board[row][0]?.type;
                    
                    for (let col = 1; col < 7; col++) {
                        if (this.board[row][col]?.type === currentType && currentType) {
                            count++;
                        } else {
                            if (count >= 3) {
                                for (let i = col - count; i < col; i++) {
                                    const key = `${row}-${i}`;
                                    if (!visited.has(key)) {
                                        matches.push({row, col: i});
                                        visited.add(key);
                                    }
                                }
                            }
                            count = 1;
                            currentType = this.board[row][col]?.type;
                        }
                    }
                    
                    if (count >= 3) {
                        for (let i = 7 - count; i < 7; i++) {
                            const key = `${row}-${i}`;
                            if (!visited.has(key)) {
                                matches.push({row, col: i});
                                visited.add(key);
                            }
                        }
                    }
                }
                
                for (let col = 0; col < 7; col++) {
                    let count = 1;
                    let currentType = this.board[0][col]?.type;
                    
                    for (let row = 1; row < 7; row++) {
                        if (this.board[row][col]?.type === currentType && currentType) {
                            count++;
                        } else {
                            if (count >= 3) {
                                for (let i = row - count; i < row; i++) {
                                    const key = `${i}-${col}`;
                                    if (!visited.has(key)) {
                                        matches.push({row: i, col});
                                        visited.add(key);
                                    }
                                }
                            }
                            count = 1;
                            currentType = this.board[row][col]?.type;
                        }
                    }
                    
                    if (count >= 3) {
                        for (let i = 7 - count; i < 7; i++) {
                            const key = `${i}-${col}`;
                            if (!visited.has(key)) {
                                matches.push({row: i, col});
                                visited.add(key);
                            }
                        }
                    }
                }
                
                return matches;
            }

            async dropGems() {
                for (let col = 0; col < 7; col++) {
                    let dropDistance = 0;
                    
                    for (let row = 6; row >= 0; row--) {
                        if (this.board[row][col] === null) {
                            dropDistance++;
                        } else if (dropDistance > 0) {
                            this.board[row + dropDistance][col] = this.board[row][col];
                            this.board[row][col] = null;
                            
                            const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            const newElem = document.querySelector(`[data-row="${row + dropDistance}"][data-col="${col}"]`);
                            
                            this.updateGemElement(newElem, this.board[row + dropDistance][col]);
                            newElem.style.transform = `translateY(-${dropDistance * 54}px)`;
                            newElem.style.opacity = '1';
                            
                            elem.style.opacity = '0';
                            
                            setTimeout(() => {
                                newElem.style.transform = '';
                                newElem.style.transition = 'transform 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                            }, 50);
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            async fillEmptySpaces() {
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row < 7; row++) {
                        if (this.board[row][col] === null) {
                            const gem = this.createRandomGem();
                            this.board[row][col] = gem;
                            
                            const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            if (elem) {
                                this.updateGemElement(elem, gem);
                                elem.style.opacity = '0';
                                elem.style.transform = 'translateY(-100px)';
                                
                                setTimeout(() => {
                                    elem.style.transition = 'transform 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease';
                                    elem.style.transform = '';
                                    elem.style.opacity = '1';
                                }, col * 50);
                            }
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 250));
            }

            async processVoidHunger(matches) {
                const voidMatches = matches.filter(match => {
                    const gem = this.board[match.row] && this.board[match.row][match.col];
                    return gem && gem.type === 'void';
                });
                
                if (voidMatches.length > 0) {
                    if (voidMatches.length >= 5) {
                        this.showComboIndicator('üï≥Ô∏è MEGA VOID HUNGER!');
                    } else if (voidMatches.length >= 4) {
                        this.showComboIndicator('üï≥Ô∏è VOID HUNGER!');
                    } else {
                        this.showComboIndicator('üï≥Ô∏è VOID PULL!');
                    }
                    this.playSound('void');
                    
                    for (const voidMatch of voidMatches) {
                        let consumedValue = 0;
                        const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                        
                        for (const [dr, dc] of directions) {
                            const adjRow = voidMatch.row + dr;
                            const adjCol = voidMatch.col + dc;
                            
                            if (adjRow >= 0 && adjRow < 7 && adjCol >= 0 && adjCol < 7 && this.board[adjRow][adjCol]) {
                                let scoreMultiplier = 2;
                                if (voidMatches.length >= 5) {
                                    scoreMultiplier = 3;
                                } else if (voidMatches.length >= 4) {
                                    scoreMultiplier = 2.5;
                                }
                                
                                consumedValue += this.board[adjRow][adjCol].value * scoreMultiplier;
                                this.board[adjRow][adjCol] = null;
                                
                                const consumedElem = document.querySelector(`[data-row="${adjRow}"][data-col="${adjCol}"]`);
                                if (consumedElem) {
                                    const animationSpeed = Math.max(0.2, 0.4 - (voidMatches.length * 0.03));
                                    consumedElem.style.transition = `transform ${animationSpeed}s ease-out, opacity ${animationSpeed}s ease-out`;
                                    consumedElem.style.transform = 'scale(0.1)';
                                    consumedElem.style.opacity = '0';
                                }
                            }
                        }
                        
                        const voidScore = Math.floor(consumedValue * this.multiplier * this.baseMultiplier);
                        this.score += voidScore;
                        this.animateScoreIncrease(voidScore);
                    }
                    
                    const animationDelay = Math.max(100, 150 - (voidMatches.length * 25));
                    await new Promise(resolve => setTimeout(resolve, animationDelay));
                }
            }

            async processStormSurge(matches) {
                const lightningMatches = matches.filter(match => {
                    const gem = this.board[match.row] && this.board[match.row][match.col];
                    return gem && gem.type === 'lightning';
                });

                if (lightningMatches.length > 0) {
                    this.showComboIndicator('‚ö° STORM SURGE!');
                    this.playSound('lightning');
                    
                    let totalStormScore = 0;
                    const struckGems = [];
                    
                    for (let row = 0; row < 7; row++) {
                        for (let col = 0; col < 7; col++) {
                            const gem = this.board[row][col];
                            if (gem && gem.type === 'lightning') {
                                totalStormScore += gem.value;
                                
                                struckGems.push({row, col});
                                
                                const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                                if (elem) {
                                    elem.classList.add('lightning-strike');
                                }
                            }
                        }
                    }
                    
                    const finalStormScore = Math.floor(totalStormScore * this.multiplier * this.baseMultiplier);
                    this.score += finalStormScore;
                    this.animateScoreIncrease(finalStormScore);
                    
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    for (const {row, col} of struckGems) {
                        this.board[row][col] = null;
                        const elem = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        if (elem) {
                            elem.classList.remove('lightning-strike');
                            elem.style.opacity = '0';
                            elem.style.transform = 'scale(0)';
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

			async handleExplosiveMatches(matches) {
			  const matchesByType = {};
			  for (const match of matches) {
				const gem = this.board[match.row][match.col];
				if (!gem) continue;
				matchesByType[gem.type] = matchesByType[gem.type] || [];
				matchesByType[gem.type].push(match);
			  }

			  // find any type with ‚â•4 matches
			  let explosiveMatches = [];
			  for (const typeMatches of Object.values(matchesByType)) {
				if (typeMatches.length >= 4) {
				  explosiveMatches = typeMatches;
				  break;
				}
			  }

			  if (explosiveMatches.length >= 4) {
				this.showComboIndicator('üí• EXPLOSIVE MATCH!');
				this.playSound('explode');

				let explosionScore = 0;
				const surroundingGems = new Set();
				// start with the core matched gems...
				const allExplodingGems = [...explosiveMatches];

				for (const match of explosiveMatches) {
				  const directions = [
					[-1,-1],[-1,0],[-1,1],
					[ 0,-1],       [ 0,1],
					[ 1,-1],[ 1,0],[ 1,1],
				  ];
				  for (const [dr, dc] of directions) {
					const r = match.row + dr;
					const c = match.col + dc;
					if (
					  r >= 0 && r < 7 &&
					  c >= 0 && c < 7 &&
					  this.board[r][c] &&
					  !matches.some(m => m.row === r && m.col === c)
					) {
					  const gemKey = `${r}-${c}`;
					  if (!surroundingGems.has(gemKey)) {
						surroundingGems.add(gemKey);
						explosionScore += this.board[r][c].value * 0.5;
						allExplodingGems.push({ row: r, col: c });
						// clear out so they don‚Äôt get picked up later
						this.board[r][c] = null;
					  }
					}
				  }
				}

				// animate *all* of them with your shared helper
				await this.explodeMatchedGems(allExplodingGems);

				// finally, award points
				const totalExplosionScore = Math.floor(
				  explosionScore * this.multiplier * this.baseMultiplier
				);
				this.score += totalExplosionScore;
				this.animateScoreIncrease(totalExplosionScore);
			  }
			}

            async explodeMatchedGems(matches) {
                for (const match of matches) {
                    const elem = document.querySelector(`[data-row="${match.row}"][data-col="${match.col}"]`);
                    if (elem) {
                        const angle = Math.random() * 2 * Math.PI;
                        const distance = 400 + Math.random() * 200;
                        const deltaX = Math.cos(angle) * distance;
                        const deltaY = Math.sin(angle) * distance;
                        
                        const rotation = Math.random() * 720 - 360;
                        
                        elem.style.transition = 'transform 0.6s ease-out, opacity 0.5s ease-out';
                        elem.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${rotation}deg) scale(0.3)`;
                        elem.style.opacity = '0';
                        elem.style.zIndex = '50';
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 600));
                
                for (const match of matches) {
                    const elem = document.querySelector(`[data-row="${match.row}"][data-col="${match.col}"]`);
                    if (elem) {
                        elem.style.transition = '';
                        elem.style.transform = '';
                        elem.style.opacity = '0';
                        elem.style.zIndex = '';
                    }
                }
            }

			async animateJesterGambit(rows) {
			  // 1) Gather coordinates
			  const toExplode = [];
			  rows.forEach(row => {
				for (let col = 0; col < 7; col++) {
				  toExplode.push({ row, col });
				}
			  });

			  // 2) Compute score upfront
			  let jesterScore = toExplode.reduce((sum, {row, col}) => {
				const gem = this.board[row][col];
				return sum + (gem ? gem.value : 0);
			  }, 0);

			  this.showComboIndicator('üé≠ JESTER‚ÄôS GAMBIT!');
			  this.playSound('explode');

			  // 3) Animate the fall, but _don't_ touch the model yet
			  await Promise.all(toExplode.map(({row, col}, idx) => {
				return new Promise(resolve => {
				  const el = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
				  if (!el) return resolve();  

				  // stagger by column so it waves
				  setTimeout(() => {
					el.classList.add('jester-fall');
					el.addEventListener('animationend', () => {
					  // hide it now‚Äîbut still keep its board entry for moment
					  el.style.opacity = '0';
					  resolve();
					}, { once: true });
				  }, col * 80);
				});
			  }));

			  // 4) Now actually clear out the model
			  toExplode.forEach(({row, col}) => {
				this.board[row][col] = null;
			  });

			  // 5) Award score
			  const finalJesterScore = Math.floor(
				jesterScore
				* this.multiplier
				* this.baseMultiplier
				* (this.currentCombo || 1)
			  );
			  this.score += finalJesterScore;
			  this.animateScoreIncrease(finalJesterScore);

			  // 6) Let your normal cascade logic take over
			  await this.dropGems();
			  await this.fillEmptySpaces();
			}
			
            restartGame() {
				console.log('restartGame called - preserving audio state');
				
				// Store current audio state BEFORE any changes
				const wasAudioEnabled = this.audioEnabled;
				const wasAudioPermissionGiven = this.audioPermissionGiven;
				const currentMusicVolume = this.musicVolume;
				const currentSfxVolume = this.sfxVolume;

				this.jesterGambit = false;
				this.quantumMirror = false;
				this.entropyEngine = false;
				this.matchCountSinceJester = 0;
				this.cascadeCountTotal = 0;
				// clear equipped relics and refresh UI
				this.relics = [];
				this.updateRelicsDisplay();
				// Stop current music but don't destroy audio system
				this.stopBackgroundMusic();
				
				// Reset all game state
				this.score = 0;
				this.displayScore = 0;
				this.moves = 4;
				this.floor = 1;
				this.targetScore = 800;
				this.multiplier = this.purchasedUpgrades['reality_breaker'] ? 5.0 : 1.0;
				this.selectedGem = null;
				this.animating = false;
				this.relics = [];
				this.matchCounter = 0;
				this.cascadeCount = 0;
				this.currentCombo = 0;
				this.isCurrentlyScoring = false;

				this.consumableUsesThisFloor = 0;
				this.boosterUsesThisFloor = 0;

				this.interactionsDisabled = false;
				this.originalTargetScore = null;
				
				// Reset all relic effects
				this.bonusMoves = 0;
				this.baseMultiplier = 1;
				this.fireBoost = 1;
				this.lightningBoost = 1;
				this.voidBoost = 1;
				this.gemValueBoost = 1;
				this.comboBoost = 1;
				this.luckyCharm = false;
				this.diceOfFate = false;
				this.timeDilator = false;
				this.explosiveMatches = false;
				this.gemAlchemy = false;
				this.cascadeMaster = false;
				this.voidHunger = false;
				this.stormSurge = false;
				this.lightningStrikes = {};
				
				// Clear active boosters
				this.activeBoosters = {};
				
				// Apply permanent upgrades
				this.applyPermanentUpgrades();
				
				// Hide all overlay screens
				document.getElementById('gameOverScreen').style.display = 'none';
				document.getElementById('relicSelectionScreen').style.display = 'none';
				document.getElementById('shopScreen').style.display = 'none';
				
				// Restore audio state WITHOUT reinitializing audio system
				this.audioEnabled = wasAudioEnabled;
				this.audioPermissionGiven = wasAudioPermissionGiven;
				this.musicVolume = currentMusicVolume;
				this.sfxVolume = currentSfxVolume;
				
				// Update volume settings to current preferences
				this.updateVolumeSettings();
				
				// Start appropriate music if audio was enabled
				if (this.audioEnabled && this.audioPermissionGiven) {
					this.playBackgroundMusic('bg1');
				}
				
				// Ensure audio toggle is visible and shows correct state
				this.showIngameAudioToggle();
				this.updateIngameAudioToggle();
				
				// Reset and create new board
				this.createBoard();
				document.querySelectorAll('.gem').forEach(el => {
				  el.style.gridRowStart    = +el.dataset.row + 1;
				  el.style.gridColumnStart = +el.dataset.col + 1;
				});

				this.updateUI();
				this.updateRelicsDisplay();
				this.initializeScoreDisplay();
				this.updateConsumablesDisplay();
				this.updateBoostersDisplay();

				// restart music if enabled
				if (this.audioEnabled) {
				  this.playBackgroundMusic('bg1');
				  this.showIngameAudioToggle();
				}

				console.log('Game restarted successfully with audio state preserved');
			}
		}
		
        function enableAudioAndStart() {
            // Hide audio permission screen
            document.getElementById('audioPermissionScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            
            // Create game instance and enable audio
            if (!window.tempGameForMusic) {
                window.tempGameForMusic = new Gemspire();
            }
            window.tempGameForMusic.enableAudio();
            window.tempGameForMusic.playBackgroundMusic('title');
            window.tempGameForMusic.showIngameAudioToggle();
        }

        function disableAudioAndStart() {
            // Hide audio permission screen
            document.getElementById('audioPermissionScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            
            // Create game instance but keep audio disabled
            if (!window.tempGameForMusic) {
                window.tempGameForMusic = new Gemspire();
            }
            window.tempGameForMusic.disableAudio();
            window.tempGameForMusic.showIngameAudioToggle();
        }

		function startGame() {
			console.log('startGame called - DESTROYING all audio');
			
			// Store audio preference
			const shouldEnableAudio = window.tempGameForMusic ? window.tempGameForMusic.audioEnabled : false;
			
			// COMPLETELY destroy temp game audio
			if (window.tempGameForMusic) {
				window.tempGameForMusic.destroyAllAudio();
				window.tempGameForMusic = null;
			}
			
			// COMPLETELY destroy existing game audio
			if (window.game) {
				window.game.destroyAllAudio();
				window.game = null;
			}
			
			// Hide start screen and show game
			document.getElementById('startScreen').style.display = 'none';
			document.getElementById('gameContainer').style.display = 'flex';
			
			// Wait for complete audio destruction
			setTimeout(() => {
				console.log('Creating completely new game with fresh audio');
				
				// Create completely new game instance
				window.game = new Gemspire();
				
				if (shouldEnableAudio) {
					window.game.enableAudio();
				} else {
					window.game.disableAudio();
				}
				
				window.game.initializeGame();
				console.log('New game created successfully');
			}, 300);
		}

		function restartGame() {
			console.log('Global restartGame called');
			if (window.game && typeof window.game.restartGame === 'function') {
				window.game.restartGame();
			} else {
				console.error('No game instance found or restartGame method missing!');
				// Fallback - try to restart manually
				returnToStart();
			}
		}

		function returnToStart() {
			console.log('returnToStart called - destroying all audio');
			
			// Stop all audio completely
			if (window.game) {
				window.game.destroyAllAudio();
				window.game.hideIngameAudioToggle();
			}
			
			// Hide all game screens
			document.getElementById('gameOverScreen').style.display = 'none';
			document.getElementById('gameContainer').style.display = 'none';
			document.getElementById('shopScreen').style.display = 'none';
			document.getElementById('relicSelectionScreen').style.display = 'none';
			document.getElementById('startScreen').style.display = 'flex';
			
			// Create fresh temp game for title screen
			setTimeout(() => {
				console.log('Creating fresh temp game for title screen');
				
				const audioWasEnabled = window.game ? window.game.audioEnabled : false;
				
				// Destroy old temp game if it exists
				if (window.tempGameForMusic) {
					window.tempGameForMusic.destroyAllAudio();
				}
				
				// Create completely new temp game
				window.tempGameForMusic = new Gemspire();
				
				if (audioWasEnabled) {
					window.tempGameForMusic.enableAudio();
					window.tempGameForMusic.playBackgroundMusic('title');
				} else {
					window.tempGameForMusic.disableAudio();
				}
				
				window.tempGameForMusic.showIngameAudioToggle();
			}, 200);
		}
			function openOptionsMenu() {
				if (game) {
					window.game.updateOptionsMenu();
				} else if (window.tempGameForMusic) {
                window.tempGameForMusic.updateOptionsMenu();
            }
            document.getElementById('optionsScreen').style.display = 'block';
        }

        function closeOptionsMenu() {
            document.getElementById('optionsScreen').style.display = 'none';
			window.game.applyCurrentCosmetics();
        }

        function changeGemTheme() {
            const select = document.getElementById('gemThemeSelect');
            const newTheme = select.value;
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                // Check if theme is owned
                if (newTheme === 'neon' && !gameInstance.purchasedUpgrades['gem_theme_neon']) {
                    select.value = gameInstance.activeGemTheme; // Reset to current
                    return;
                }
                
                gameInstance.activeGemTheme = newTheme;
                gameInstance.saveGameSettings();
                
                // Apply immediately if in game
                if (game) {
                    gameInstance.applyCurrentCosmetics();
                }
            }
        }

        function changeBoardTheme() {
            const select = document.getElementById('boardThemeSelect');
            const newTheme = select.value;
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                // Check if theme is owned
                if (newTheme === 'space' && !gameInstance.purchasedUpgrades['board_theme_space']) {
                    select.value = gameInstance.activeBoardTheme; // Reset to current
                    return;
                }
                
                gameInstance.activeBoardTheme = newTheme;
                gameInstance.saveGameSettings();
                
                // Apply immediately if in game
                if (game) {
                    gameInstance.applyCurrentCosmetics();
                }
            }
        }

        function changeParticleEffects() {
            const select = document.getElementById('particleEffectsSelect');
            const enabled = select.value === 'true';
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                // Check if effect is owned
                if (enabled && !gameInstance.purchasedUpgrades['particle_effects']) {
                    select.value = gameInstance.activeParticleEffects.toString(); // Reset to current
                    return;
                }
                
                gameInstance.activeParticleEffects = enabled;
                gameInstance.saveGameSettings();
            }
        }

        function changeMusicVolume() {
            const slider = document.getElementById('musicVolumeSlider');
            const value = parseInt(slider.value);
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                gameInstance.musicVolume = value;
                gameInstance.updateVolumeSettings();
                gameInstance.saveGameSettings();
                document.getElementById('musicVolumeValue').textContent = value + '%';
            }
        }

        function changeSFXVolume() {
            const slider = document.getElementById('sfxVolumeSlider');
            const value = parseInt(slider.value);
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                gameInstance.sfxVolume = value;
                gameInstance.updateVolumeSettings();
                gameInstance.saveGameSettings();
                document.getElementById('sfxVolumeValue').textContent = value + '%';
            }
        }

        function toggleAutoSave() {
            const checkbox = document.getElementById('autoSaveCheckbox');
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                gameInstance.autoSave = checkbox.checked;
                gameInstance.saveGameSettings();
            }
        }

        function toggleAnimations() {
            const checkbox = document.getElementById('animationsCheckbox');
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                gameInstance.animations = checkbox.checked;
                gameInstance.saveGameSettings();
                
                // Apply animation setting to body
                if (checkbox.checked) {
                    document.body.classList.remove('no-animations');
                } else {
                    document.body.classList.add('no-animations');
                }
            }
        }

        function resetOptions() {
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                gameInstance.activeGemTheme = 'default';
                gameInstance.activeBoardTheme = 'default';
                gameInstance.activeParticleEffects = false;
                gameInstance.musicVolume = 30;
                gameInstance.sfxVolume = 50;
                gameInstance.autoSave = true;
                gameInstance.animations = true;
                
                gameInstance.updateVolumeSettings();
                gameInstance.saveGameSettings();
                gameInstance.updateOptionsMenu();
                
                // Apply changes immediately if in game
                if (game) {
                    gameInstance.applyCurrentCosmetics();
                }
                
                document.body.classList.remove('no-animations');
            }
        }

        function handleTransmuterClick(gemType, row, col) {
            console.log('handleTransmuterClick called:', gemType, row, col);
            
            // Immediately close any other modals that might be open
            document.getElementById('purchaseConfirmation').style.display = 'none';
            document.getElementById('optionsScreen').style.display = 'none';
            
            const gameInstance = window.game || window.tempGameForMusic;
            if (gameInstance) {
                // Force close the modal first
                document.getElementById('gemSelectionModal').style.display = 'none';
                
                // Apply the transmutation immediately
                gameInstance.applyGemTransmutation(row, col, gemType);
            } else {
                console.error('No game instance found!');
            }
        }

		function toggleIngameAudio() {
			console.log('toggleIngameAudio called');
			console.log('window.game exists:', !!window.game);
			console.log('window.tempGameForMusic exists:', !!window.tempGameForMusic);
			
			if (window.game) {
				console.log('Using window.game instance');
				window.game.toggleIngameAudio();
			} else if (window.tempGameForMusic) {
				console.log('Using tempGameForMusic instance');
				window.tempGameForMusic.toggleIngameAudio();
			} else {
				console.log('No game instance found');
			}
		}

		function closeShop() {
			console.log('Global closeShop called');
			
			if (window.game) {
				window.game.closeShop();
			} else if (window.tempGameForMusic) {
				window.tempGameForMusic.closeShop();
			} else {
				// Fallback
				console.log('No game instance, manually closing shop');
				document.getElementById('shopScreen').style.display = 'none';
			}
		}

		function switchShopTab(category) {
			if (window.game) {
				window.game.switchShopTab(category);
			} else if (window.tempGameForMusic) {
				window.tempGameForMusic.switchShopTab(category);
			}
		}

		function confirmPurchase() {
			if (window.game) {
				window.game.confirmPurchase();
			} else if (window.tempGameForMusic) {
				window.tempGameForMusic.confirmPurchase();
			}
		}

		function cancelPurchase() {
			if (window.game) {
				window.game.cancelPurchase();
			} else if (window.tempGameForMusic) {
				window.tempGameForMusic.cancelPurchase();
			}
		}

        let game;

        window.addEventListener('load', () => {
            // Show audio permission screen first
            document.getElementById('audioPermissionScreen').style.display = 'flex';
        });
    </script>
</body>
</html>
4. most importantly, output comprehensive code